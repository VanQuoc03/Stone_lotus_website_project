import { ref as _e, computed as me, nextTick as We, createElementBlock as W, openBlock as P, renderSlot as qe, createElementVNode as re, inject as Lo, isRef as ic, defineComponent as ye, createVNode as ke, withCtx as Me, createTextVNode as qt, toDisplayString as He, unref as K, createCommentVNode as xe, getCurrentScope as ac, onScopeDispose as lc, readonly as uc, createBlock as pe, withModifiers as qo, onMounted as Ge, onUnmounted as fc, normalizeStyle as hc, withDirectives as Fo, withKeys as pc, vModelText as dc, Fragment as un, renderList as fn, onBeforeUnmount as gc, h as _c, toRefs as mc, normalizeClass as Oo, normalizeProps as ar, guardReactiveProps as bc, resolveDynamicComponent as vc, mergeProps as Bo, watch as kc, resolveComponent as lr, Transition as ur, vShow as xc, createApp as yc } from "vue";
const Ze = {
  webhookUrl: "http://localhost:5678",
  webhookConfig: {
    method: "POST",
    headers: {}
  },
  target: "#n8n-chat",
  mode: "window",
  loadPreviousSession: !0,
  chatInputKey: "chatInput",
  chatSessionKey: "sessionId",
  defaultLanguage: "en",
  showWelcomeScreen: !1,
  initialMessages: ["Hi there! 👋", "My name is Nathan. How can I assist you today?"],
  i18n: {
    en: {
      title: "Hi there! 👋",
      subtitle: "Start a chat. We're here to help you 24/7.",
      footer: "",
      getStarted: "New Conversation",
      inputPlaceholder: "Type your question..",
      closeButtonTooltip: "Close chat"
    }
  },
  theme: {}
}, Ec = "#n8n-chat", Ac = "n8n-chat", fr = `${Ac}/sessionId`, Po = "Chat", zo = "ChatOptions";
var he = [];
for (var yn = 0; yn < 256; ++yn)
  he.push((yn + 256).toString(16).slice(1));
function Cc(c, n = 0) {
  return (he[c[n + 0]] + he[c[n + 1]] + he[c[n + 2]] + he[c[n + 3]] + "-" + he[c[n + 4]] + he[c[n + 5]] + "-" + he[c[n + 6]] + he[c[n + 7]] + "-" + he[c[n + 8]] + he[c[n + 9]] + "-" + he[c[n + 10]] + he[c[n + 11]] + he[c[n + 12]] + he[c[n + 13]] + he[c[n + 14]] + he[c[n + 15]]).toLowerCase();
}
var sn, wc = new Uint8Array(16);
function Sc() {
  if (!sn && (sn = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !sn))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return sn(wc);
}
var Rc = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const hr = {
  randomUUID: Rc
};
function je(c, n, o) {
  if (hr.randomUUID && !c)
    return hr.randomUUID();
  c = c || {};
  var e = c.random || (c.rng || Sc)();
  return e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128, Cc(e);
}
async function Dc() {
  return "";
}
async function Ft(...c) {
  var r, s;
  const n = await Dc(), o = (r = c[1]) == null ? void 0 : r.body, e = {
    ...n ? { authorization: `Bearer ${n}` } : {},
    ...(s = c[1]) == null ? void 0 : s.headers
  };
  return o instanceof FormData ? delete e["Content-Type"] : e["Content-Type"] = "application/json", await (await fetch(c[0], {
    ...c[1],
    mode: "cors",
    cache: "no-cache",
    headers: e
  })).json();
}
async function $o(c, n = {}, o = {}) {
  let e = c;
  return Object.keys(n).length > 0 && (e = `${e}?${new URLSearchParams(
    n
  ).toString()}`), await Ft(e, { ...o, method: "GET" });
}
async function Uo(c, n = {}, o = {}) {
  return await Ft(c, {
    ...o,
    method: "POST",
    body: JSON.stringify(n)
  });
}
async function Tc(c, n = {}, o = [], e = {}) {
  const t = new FormData();
  for (const r in n)
    t.append(r, n[r]);
  for (const r of o)
    t.append("files", r);
  return await Ft(c, {
    ...e,
    method: "POST",
    body: t
  });
}
async function Mc(c, n) {
  var e, t;
  return await (((e = n.webhookConfig) == null ? void 0 : e.method) === "POST" ? Uo : $o)(
    `${n.webhookUrl}`,
    {
      action: "loadPreviousSession",
      [n.chatSessionKey]: c,
      ...n.metadata ? { metadata: n.metadata } : {}
    },
    {
      headers: (t = n.webhookConfig) == null ? void 0 : t.headers
    }
  );
}
async function Nc(c, n, o, e) {
  var r, s, i;
  return n.length > 0 ? await Tc(
    `${e.webhookUrl}`,
    {
      action: "sendMessage",
      [e.chatSessionKey]: o,
      [e.chatInputKey]: c,
      ...e.metadata ? { metadata: e.metadata } : {}
    },
    n,
    {
      headers: (r = e.webhookConfig) == null ? void 0 : r.headers
    }
  ) : await (((s = e.webhookConfig) == null ? void 0 : s.method) === "POST" ? Uo : $o)(
    `${e.webhookUrl}`,
    {
      action: "sendMessage",
      [e.chatSessionKey]: o,
      [e.chatInputKey]: c,
      ...e.metadata ? { metadata: e.metadata } : {}
    },
    {
      headers: (i = e.webhookConfig) == null ? void 0 : i.headers
    }
  );
}
function Ic() {
  const c = /* @__PURE__ */ new Map();
  function n(t, r) {
    const s = c.get(t);
    s && s.splice(s.indexOf(r) >>> 0, 1);
  }
  function o(t, r) {
    let s = c.get(t);
    return s ? s.push(r) : s = [r], c.set(t, s), () => n(t, r);
  }
  function e(t, r) {
    const s = c.get(t);
    s && s.slice().forEach(async (i) => {
      await i(r);
    });
  }
  return {
    on: o,
    off: n,
    emit: e
  };
}
function Lc(c) {
  if (!document.querySelector(c)) {
    const o = document.createElement("div");
    c.startsWith("#") && (o.id = c.replace("#", "")), c.startsWith(".") && o.classList.add(c.replace(".", "")), document.body.appendChild(o);
  }
}
const be = Ic(), qc = {
  install(c, n) {
    c.provide(zo, n);
    const o = _e([]), e = _e(null), t = _e(!1), r = me(
      () => (n.initialMessages ?? []).map((f) => ({
        id: je(),
        text: f,
        sender: "bot"
      }))
    );
    async function s(f, u = []) {
      const d = {
        id: je(),
        text: f,
        sender: "user",
        files: u
      };
      o.value.push(d), t.value = !0, We(() => {
        be.emit("scrollToBottom");
      });
      const h = await Nc(
        f,
        u,
        e.value,
        n
      );
      let _ = h.output ?? h.text ?? "";
      if (_ === "" && Object.keys(h).length > 0)
        try {
          _ = JSON.stringify(h, null, 2);
        } catch {
        }
      const v = {
        id: je(),
        text: _,
        sender: "bot"
      };
      o.value.push(v), t.value = !1, We(() => {
        be.emit("scrollToBottom");
      });
    }
    async function i() {
      if (!n.loadPreviousSession)
        return;
      const f = localStorage.getItem(fr) ?? je(), u = await Mc(f, n);
      return o.value = ((u == null ? void 0 : u.data) || []).map((d, h) => ({
        id: `${h}`,
        text: d.kwargs.content,
        sender: d.id.includes("HumanMessage") ? "user" : "bot"
      })), o.value.length && (e.value = f), f;
    }
    async function a() {
      e.value = je(), localStorage.setItem(fr, e.value);
    }
    const l = {
      initialMessages: r,
      messages: o,
      currentSessionId: e,
      waitingForResponse: t,
      loadPreviousSession: i,
      startNewSession: a,
      sendMessage: s
    };
    c.provide(Po, l), c.config.globalProperties.$chat = l;
  }
};
function Ot(c) {
  return c && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c;
}
function Fc(c) {
  if (Object.prototype.hasOwnProperty.call(c, "__esModule")) return c;
  var n = c.default;
  if (typeof n == "function") {
    var o = function e() {
      return this instanceof e ? Reflect.construct(n, arguments, this.constructor) : n.apply(this, arguments);
    };
    o.prototype = n.prototype;
  } else o = {};
  return Object.defineProperty(o, "__esModule", { value: !0 }), Object.keys(c).forEach(function(e) {
    var t = Object.getOwnPropertyDescriptor(c, e);
    Object.defineProperty(o, e, t.get ? t : {
      enumerable: !0,
      get: function() {
        return c[e];
      }
    });
  }), o;
}
var En, pr;
function Oc() {
  if (pr) return En;
  pr = 1;
  function c(p) {
    return p instanceof Map ? p.clear = p.delete = p.set = function() {
      throw new Error("map is read-only");
    } : p instanceof Set && (p.add = p.clear = p.delete = function() {
      throw new Error("set is read-only");
    }), Object.freeze(p), Object.getOwnPropertyNames(p).forEach((A) => {
      const T = p[A], H = typeof T;
      (H === "object" || H === "function") && !Object.isFrozen(T) && c(T);
    }), p;
  }
  class n {
    /**
     * @param {CompiledMode} mode
     */
    constructor(A) {
      A.data === void 0 && (A.data = {}), this.data = A.data, this.isMatchIgnored = !1;
    }
    ignoreMatch() {
      this.isMatchIgnored = !0;
    }
  }
  function o(p) {
    return p.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  }
  function e(p, ...A) {
    const T = /* @__PURE__ */ Object.create(null);
    for (const H in p)
      T[H] = p[H];
    return A.forEach(function(H) {
      for (const se in H)
        T[se] = H[se];
    }), /** @type {T} */
    T;
  }
  const t = "</span>", r = (p) => !!p.scope, s = (p, { prefix: A }) => {
    if (p.startsWith("language:"))
      return p.replace("language:", "language-");
    if (p.includes(".")) {
      const T = p.split(".");
      return [
        `${A}${T.shift()}`,
        ...T.map((H, se) => `${H}${"_".repeat(se + 1)}`)
      ].join(" ");
    }
    return `${A}${p}`;
  };
  class i {
    /**
     * Creates a new HTMLRenderer
     *
     * @param {Tree} parseTree - the parse tree (must support `walk` API)
     * @param {{classPrefix: string}} options
     */
    constructor(A, T) {
      this.buffer = "", this.classPrefix = T.classPrefix, A.walk(this);
    }
    /**
     * Adds texts to the output stream
     *
     * @param {string} text */
    addText(A) {
      this.buffer += o(A);
    }
    /**
     * Adds a node open to the output stream (if needed)
     *
     * @param {Node} node */
    openNode(A) {
      if (!r(A)) return;
      const T = s(
        A.scope,
        { prefix: this.classPrefix }
      );
      this.span(T);
    }
    /**
     * Adds a node close to the output stream (if needed)
     *
     * @param {Node} node */
    closeNode(A) {
      r(A) && (this.buffer += t);
    }
    /**
     * returns the accumulated buffer
    */
    value() {
      return this.buffer;
    }
    // helpers
    /**
     * Builds a span element
     *
     * @param {string} className */
    span(A) {
      this.buffer += `<span class="${A}">`;
    }
  }
  const a = (p = {}) => {
    const A = { children: [] };
    return Object.assign(A, p), A;
  };
  class l {
    constructor() {
      this.rootNode = a(), this.stack = [this.rootNode];
    }
    get top() {
      return this.stack[this.stack.length - 1];
    }
    get root() {
      return this.rootNode;
    }
    /** @param {Node} node */
    add(A) {
      this.top.children.push(A);
    }
    /** @param {string} scope */
    openNode(A) {
      const T = a({ scope: A });
      this.add(T), this.stack.push(T);
    }
    closeNode() {
      if (this.stack.length > 1)
        return this.stack.pop();
    }
    closeAllNodes() {
      for (; this.closeNode(); ) ;
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    /**
     * @typedef { import("./html_renderer").Renderer } Renderer
     * @param {Renderer} builder
     */
    walk(A) {
      return this.constructor._walk(A, this.rootNode);
    }
    /**
     * @param {Renderer} builder
     * @param {Node} node
     */
    static _walk(A, T) {
      return typeof T == "string" ? A.addText(T) : T.children && (A.openNode(T), T.children.forEach((H) => this._walk(A, H)), A.closeNode(T)), A;
    }
    /**
     * @param {Node} node
     */
    static _collapse(A) {
      typeof A != "string" && A.children && (A.children.every((T) => typeof T == "string") ? A.children = [A.children.join("")] : A.children.forEach((T) => {
        l._collapse(T);
      }));
    }
  }
  class f extends l {
    /**
     * @param {*} options
     */
    constructor(A) {
      super(), this.options = A;
    }
    /**
     * @param {string} text
     */
    addText(A) {
      A !== "" && this.add(A);
    }
    /** @param {string} scope */
    startScope(A) {
      this.openNode(A);
    }
    endScope() {
      this.closeNode();
    }
    /**
     * @param {Emitter & {root: DataNode}} emitter
     * @param {string} name
     */
    __addSublanguage(A, T) {
      const H = A.root;
      T && (H.scope = `language:${T}`), this.add(H);
    }
    toHTML() {
      return new i(this, this.options).value();
    }
    finalize() {
      return this.closeAllNodes(), !0;
    }
  }
  function u(p) {
    return p ? typeof p == "string" ? p : p.source : null;
  }
  function d(p) {
    return v("(?=", p, ")");
  }
  function h(p) {
    return v("(?:", p, ")*");
  }
  function _(p) {
    return v("(?:", p, ")?");
  }
  function v(...p) {
    return p.map((T) => u(T)).join("");
  }
  function E(p) {
    const A = p[p.length - 1];
    return typeof A == "object" && A.constructor === Object ? (p.splice(p.length - 1, 1), A) : {};
  }
  function b(...p) {
    return "(" + (E(p).capture ? "" : "?:") + p.map((H) => u(H)).join("|") + ")";
  }
  function x(p) {
    return new RegExp(p.toString() + "|").exec("").length - 1;
  }
  function g(p, A) {
    const T = p && p.exec(A);
    return T && T.index === 0;
  }
  const m = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  function k(p, { joinWith: A }) {
    let T = 0;
    return p.map((H) => {
      T += 1;
      const se = T;
      let ce = u(H), F = "";
      for (; ce.length > 0; ) {
        const L = m.exec(ce);
        if (!L) {
          F += ce;
          break;
        }
        F += ce.substring(0, L.index), ce = ce.substring(L.index + L[0].length), L[0][0] === "\\" && L[1] ? F += "\\" + String(Number(L[1]) + se) : (F += L[0], L[0] === "(" && T++);
      }
      return F;
    }).map((H) => `(${H})`).join(A);
  }
  const y = /\b\B/, I = "[a-zA-Z]\\w*", w = "[a-zA-Z_]\\w*", D = "\\b\\d+(\\.\\d+)?", R = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", q = "\\b(0b[01]+)", V = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", ne = (p = {}) => {
    const A = /^#![ ]*\//;
    return p.binary && (p.begin = v(
      A,
      /.*\b/,
      p.binary,
      /\b.*/
    )), e({
      scope: "meta",
      begin: A,
      end: /$/,
      relevance: 0,
      /** @type {ModeCallback} */
      "on:begin": (T, H) => {
        T.index !== 0 && H.ignoreMatch();
      }
    }, p);
  }, C = {
    begin: "\\\\[\\s\\S]",
    relevance: 0
  }, M = {
    scope: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [C]
  }, $ = {
    scope: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [C]
  }, J = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  }, Z = function(p, A, T = {}) {
    const H = e(
      {
        scope: "comment",
        begin: p,
        end: A,
        contains: []
      },
      T
    );
    H.contains.push({
      scope: "doctag",
      // hack to avoid the space from being included. the space is necessary to
      // match here to prevent the plain text rule below from gobbling up doctags
      begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
      end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
      excludeBegin: !0,
      relevance: 0
    });
    const se = b(
      // list of common 1 and 2 letter words in English
      "I",
      "a",
      "is",
      "so",
      "us",
      "to",
      "at",
      "if",
      "in",
      "it",
      "on",
      // note: this is not an exhaustive list of contractions, just popular ones
      /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
      // contractions - can't we'd they're let's, etc
      /[A-Za-z]+[-][a-z]+/,
      // `no-way`, etc.
      /[A-Za-z][a-z]{2,}/
      // allow capitalized words at beginning of sentences
    );
    return H.contains.push(
      {
        // TODO: how to include ", (, ) without breaking grammars that use these for
        // comment delimiters?
        // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
        // ---
        // this tries to find sequences of 3 english words in a row (without any
        // "programming" type syntax) this gives us a strong signal that we've
        // TRULY found a comment - vs perhaps scanning with the wrong language.
        // It's possible to find something that LOOKS like the start of the
        // comment - but then if there is no readable text - good chance it is a
        // false match and not a comment.
        //
        // for a visual example please see:
        // https://github.com/highlightjs/highlight.js/issues/2827
        begin: v(
          /[ ]+/,
          // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
          "(",
          se,
          /[.]?[:]?([.][ ]|[ ])/,
          "){3}"
        )
        // look for 3 words in a row
      }
    ), H;
  }, X = Z("//", "$"), O = Z("/\\*", "\\*/"), ae = Z("#", "$"), de = {
    scope: "number",
    begin: D,
    relevance: 0
  }, Ee = {
    scope: "number",
    begin: R,
    relevance: 0
  }, ms = {
    scope: "number",
    begin: q,
    relevance: 0
  }, bs = {
    scope: "regexp",
    begin: /\/(?=[^/\n]*\/)/,
    end: /\/[gimuy]*/,
    contains: [
      C,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [C]
      }
    ]
  }, vs = {
    scope: "title",
    begin: I,
    relevance: 0
  }, ks = {
    scope: "title",
    begin: w,
    relevance: 0
  }, xs = {
    // excludes method names from keyword processing
    begin: "\\.\\s*" + w,
    relevance: 0
  };
  var Xe = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    APOS_STRING_MODE: M,
    BACKSLASH_ESCAPE: C,
    BINARY_NUMBER_MODE: ms,
    BINARY_NUMBER_RE: q,
    COMMENT: Z,
    C_BLOCK_COMMENT_MODE: O,
    C_LINE_COMMENT_MODE: X,
    C_NUMBER_MODE: Ee,
    C_NUMBER_RE: R,
    END_SAME_AS_BEGIN: function(p) {
      return Object.assign(
        p,
        {
          /** @type {ModeCallback} */
          "on:begin": (A, T) => {
            T.data._beginMatch = A[1];
          },
          /** @type {ModeCallback} */
          "on:end": (A, T) => {
            T.data._beginMatch !== A[1] && T.ignoreMatch();
          }
        }
      );
    },
    HASH_COMMENT_MODE: ae,
    IDENT_RE: I,
    MATCH_NOTHING_RE: y,
    METHOD_GUARD: xs,
    NUMBER_MODE: de,
    NUMBER_RE: D,
    PHRASAL_WORDS_MODE: J,
    QUOTE_STRING_MODE: $,
    REGEXP_MODE: bs,
    RE_STARTERS_RE: V,
    SHEBANG: ne,
    TITLE_MODE: vs,
    UNDERSCORE_IDENT_RE: w,
    UNDERSCORE_TITLE_MODE: ks
  });
  function ys(p, A) {
    p.input[p.index - 1] === "." && A.ignoreMatch();
  }
  function Es(p, A) {
    p.className !== void 0 && (p.scope = p.className, delete p.className);
  }
  function As(p, A) {
    A && p.beginKeywords && (p.begin = "\\b(" + p.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", p.__beforeBegin = ys, p.keywords = p.keywords || p.beginKeywords, delete p.beginKeywords, p.relevance === void 0 && (p.relevance = 0));
  }
  function Cs(p, A) {
    Array.isArray(p.illegal) && (p.illegal = b(...p.illegal));
  }
  function ws(p, A) {
    if (p.match) {
      if (p.begin || p.end) throw new Error("begin & end are not supported with match");
      p.begin = p.match, delete p.match;
    }
  }
  function Ss(p, A) {
    p.relevance === void 0 && (p.relevance = 1);
  }
  const Rs = (p, A) => {
    if (!p.beforeMatch) return;
    if (p.starts) throw new Error("beforeMatch cannot be used with starts");
    const T = Object.assign({}, p);
    Object.keys(p).forEach((H) => {
      delete p[H];
    }), p.keywords = T.keywords, p.begin = v(T.beforeMatch, d(T.begin)), p.starts = {
      relevance: 0,
      contains: [
        Object.assign(T, { endsParent: !0 })
      ]
    }, p.relevance = 0, delete T.beforeMatch;
  }, Ds = [
    "of",
    "and",
    "for",
    "in",
    "not",
    "or",
    "if",
    "then",
    "parent",
    // common variable name
    "list",
    // common variable name
    "value"
    // common variable name
  ], Ts = "keyword";
  function Zt(p, A, T = Ts) {
    const H = /* @__PURE__ */ Object.create(null);
    return typeof p == "string" ? se(T, p.split(" ")) : Array.isArray(p) ? se(T, p) : Object.keys(p).forEach(function(ce) {
      Object.assign(
        H,
        Zt(p[ce], A, ce)
      );
    }), H;
    function se(ce, F) {
      A && (F = F.map((L) => L.toLowerCase())), F.forEach(function(L) {
        const U = L.split("|");
        H[U[0]] = [ce, Ms(U[0], U[1])];
      });
    }
  }
  function Ms(p, A) {
    return A ? Number(A) : Ns(p) ? 0 : 1;
  }
  function Ns(p) {
    return Ds.includes(p.toLowerCase());
  }
  const jt = {}, Fe = (p) => {
    console.error(p);
  }, Kt = (p, ...A) => {
    console.log(`WARN: ${p}`, ...A);
  }, Pe = (p, A) => {
    jt[`${p}/${A}`] || (console.log(`Deprecated as of ${p}. ${A}`), jt[`${p}/${A}`] = !0);
  }, Qe = new Error();
  function Wt(p, A, { key: T }) {
    let H = 0;
    const se = p[T], ce = {}, F = {};
    for (let L = 1; L <= A.length; L++)
      F[L + H] = se[L], ce[L + H] = !0, H += x(A[L - 1]);
    p[T] = F, p[T]._emit = ce, p[T]._multi = !0;
  }
  function Is(p) {
    if (Array.isArray(p.begin)) {
      if (p.skip || p.excludeBegin || p.returnBegin)
        throw Fe("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Qe;
      if (typeof p.beginScope != "object" || p.beginScope === null)
        throw Fe("beginScope must be object"), Qe;
      Wt(p, p.begin, { key: "beginScope" }), p.begin = k(p.begin, { joinWith: "" });
    }
  }
  function Ls(p) {
    if (Array.isArray(p.end)) {
      if (p.skip || p.excludeEnd || p.returnEnd)
        throw Fe("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Qe;
      if (typeof p.endScope != "object" || p.endScope === null)
        throw Fe("endScope must be object"), Qe;
      Wt(p, p.end, { key: "endScope" }), p.end = k(p.end, { joinWith: "" });
    }
  }
  function qs(p) {
    p.scope && typeof p.scope == "object" && p.scope !== null && (p.beginScope = p.scope, delete p.scope);
  }
  function Fs(p) {
    qs(p), typeof p.beginScope == "string" && (p.beginScope = { _wrap: p.beginScope }), typeof p.endScope == "string" && (p.endScope = { _wrap: p.endScope }), Is(p), Ls(p);
  }
  function Os(p) {
    function A(F, L) {
      return new RegExp(
        u(F),
        "m" + (p.case_insensitive ? "i" : "") + (p.unicodeRegex ? "u" : "") + (L ? "g" : "")
      );
    }
    class T {
      constructor() {
        this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
      }
      // @ts-ignore
      addRule(L, U) {
        U.position = this.position++, this.matchIndexes[this.matchAt] = U, this.regexes.push([U, L]), this.matchAt += x(L) + 1;
      }
      compile() {
        this.regexes.length === 0 && (this.exec = () => null);
        const L = this.regexes.map((U) => U[1]);
        this.matcherRe = A(k(L, { joinWith: "|" }), !0), this.lastIndex = 0;
      }
      /** @param {string} s */
      exec(L) {
        this.matcherRe.lastIndex = this.lastIndex;
        const U = this.matcherRe.exec(L);
        if (!U)
          return null;
        const ue = U.findIndex((Ve, _n) => _n > 0 && Ve !== void 0), ie = this.matchIndexes[ue];
        return U.splice(0, ue), Object.assign(U, ie);
      }
    }
    class H {
      constructor() {
        this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
      }
      // @ts-ignore
      getMatcher(L) {
        if (this.multiRegexes[L]) return this.multiRegexes[L];
        const U = new T();
        return this.rules.slice(L).forEach(([ue, ie]) => U.addRule(ue, ie)), U.compile(), this.multiRegexes[L] = U, U;
      }
      resumingScanAtSamePosition() {
        return this.regexIndex !== 0;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      // @ts-ignore
      addRule(L, U) {
        this.rules.push([L, U]), U.type === "begin" && this.count++;
      }
      /** @param {string} s */
      exec(L) {
        const U = this.getMatcher(this.regexIndex);
        U.lastIndex = this.lastIndex;
        let ue = U.exec(L);
        if (this.resumingScanAtSamePosition() && !(ue && ue.index === this.lastIndex)) {
          const ie = this.getMatcher(0);
          ie.lastIndex = this.lastIndex + 1, ue = ie.exec(L);
        }
        return ue && (this.regexIndex += ue.position + 1, this.regexIndex === this.count && this.considerAll()), ue;
      }
    }
    function se(F) {
      const L = new H();
      return F.contains.forEach((U) => L.addRule(U.begin, { rule: U, type: "begin" })), F.terminatorEnd && L.addRule(F.terminatorEnd, { type: "end" }), F.illegal && L.addRule(F.illegal, { type: "illegal" }), L;
    }
    function ce(F, L) {
      const U = (
        /** @type CompiledMode */
        F
      );
      if (F.isCompiled) return U;
      [
        Es,
        // do this early so compiler extensions generally don't have to worry about
        // the distinction between match/begin
        ws,
        Fs,
        Rs
      ].forEach((ie) => ie(F, L)), p.compilerExtensions.forEach((ie) => ie(F, L)), F.__beforeBegin = null, [
        As,
        // do this later so compiler extensions that come earlier have access to the
        // raw array if they wanted to perhaps manipulate it, etc.
        Cs,
        // default to 1 relevance if not specified
        Ss
      ].forEach((ie) => ie(F, L)), F.isCompiled = !0;
      let ue = null;
      return typeof F.keywords == "object" && F.keywords.$pattern && (F.keywords = Object.assign({}, F.keywords), ue = F.keywords.$pattern, delete F.keywords.$pattern), ue = ue || /\w+/, F.keywords && (F.keywords = Zt(F.keywords, p.case_insensitive)), U.keywordPatternRe = A(ue, !0), L && (F.begin || (F.begin = /\B|\b/), U.beginRe = A(U.begin), !F.end && !F.endsWithParent && (F.end = /\B|\b/), F.end && (U.endRe = A(U.end)), U.terminatorEnd = u(U.end) || "", F.endsWithParent && L.terminatorEnd && (U.terminatorEnd += (F.end ? "|" : "") + L.terminatorEnd)), F.illegal && (U.illegalRe = A(
        /** @type {RegExp | string} */
        F.illegal
      )), F.contains || (F.contains = []), F.contains = [].concat(...F.contains.map(function(ie) {
        return Bs(ie === "self" ? F : ie);
      })), F.contains.forEach(function(ie) {
        ce(
          /** @type Mode */
          ie,
          U
        );
      }), F.starts && ce(F.starts, L), U.matcher = se(U), U;
    }
    if (p.compilerExtensions || (p.compilerExtensions = []), p.contains && p.contains.includes("self"))
      throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
    return p.classNameAliases = e(p.classNameAliases || {}), ce(
      /** @type Mode */
      p
    );
  }
  function Yt(p) {
    return p ? p.endsWithParent || Yt(p.starts) : !1;
  }
  function Bs(p) {
    return p.variants && !p.cachedVariants && (p.cachedVariants = p.variants.map(function(A) {
      return e(p, { variants: null }, A);
    })), p.cachedVariants ? p.cachedVariants : Yt(p) ? e(p, { starts: p.starts ? e(p.starts) : null }) : Object.isFrozen(p) ? e(p) : p;
  }
  var Ps = "11.9.0";
  class zs extends Error {
    constructor(A, T) {
      super(A), this.name = "HTMLInjectionError", this.html = T;
    }
  }
  const gn = o, Jt = e, Xt = Symbol("nomatch"), $s = 7, Qt = function(p) {
    const A = /* @__PURE__ */ Object.create(null), T = /* @__PURE__ */ Object.create(null), H = [];
    let se = !0;
    const ce = "Could not find the language '{}', did you forget to load/include a language module?", F = { disableAutodetect: !0, name: "Plain text", contains: [] };
    let L = {
      ignoreUnescapedHTML: !1,
      throwUnescapedHTML: !1,
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      cssSelector: "pre code",
      languages: null,
      // beta configuration options, subject to change, welcome to discuss
      // https://github.com/highlightjs/highlight.js/issues/1086
      __emitter: f
    };
    function U(S) {
      return L.noHighlightRe.test(S);
    }
    function ue(S) {
      let z = S.className + " ";
      z += S.parentNode ? S.parentNode.className : "";
      const Y = L.languageDetectRe.exec(z);
      if (Y) {
        const te = Ne(Y[1]);
        return te || (Kt(ce.replace("{}", Y[1])), Kt("Falling back to no-highlight mode for this block.", S)), te ? Y[1] : "no-highlight";
      }
      return z.split(/\s+/).find((te) => U(te) || Ne(te));
    }
    function ie(S, z, Y) {
      let te = "", le = "";
      typeof z == "object" ? (te = S, Y = z.ignoreIllegals, le = z.language) : (Pe("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Pe("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), le = S, te = z), Y === void 0 && (Y = !0);
      const Ae = {
        code: te,
        language: le
      };
      nn("before:highlight", Ae);
      const Ie = Ae.result ? Ae.result : Ve(Ae.language, Ae.code, Y);
      return Ie.code = Ae.code, nn("after:highlight", Ie), Ie;
    }
    function Ve(S, z, Y, te) {
      const le = /* @__PURE__ */ Object.create(null);
      function Ae(N, B) {
        return N.keywords[B];
      }
      function Ie() {
        if (!G.keywords) {
          fe.addText(oe);
          return;
        }
        let N = 0;
        G.keywordPatternRe.lastIndex = 0;
        let B = G.keywordPatternRe.exec(oe), j = "";
        for (; B; ) {
          j += oe.substring(N, B.index);
          const ee = we.case_insensitive ? B[0].toLowerCase() : B[0], ge = Ae(G, ee);
          if (ge) {
            const [De, sc] = ge;
            if (fe.addText(j), j = "", le[ee] = (le[ee] || 0) + 1, le[ee] <= $s && (on += sc), De.startsWith("_"))
              j += B[0];
            else {
              const cc = we.classNameAliases[De] || De;
              Ce(B[0], cc);
            }
          } else
            j += B[0];
          N = G.keywordPatternRe.lastIndex, B = G.keywordPatternRe.exec(oe);
        }
        j += oe.substring(N), fe.addText(j);
      }
      function tn() {
        if (oe === "") return;
        let N = null;
        if (typeof G.subLanguage == "string") {
          if (!A[G.subLanguage]) {
            fe.addText(oe);
            return;
          }
          N = Ve(G.subLanguage, oe, !0, ir[G.subLanguage]), ir[G.subLanguage] = /** @type {CompiledMode} */
          N._top;
        } else
          N = mn(oe, G.subLanguage.length ? G.subLanguage : null);
        G.relevance > 0 && (on += N.relevance), fe.__addSublanguage(N._emitter, N.language);
      }
      function ve() {
        G.subLanguage != null ? tn() : Ie(), oe = "";
      }
      function Ce(N, B) {
        N !== "" && (fe.startScope(B), fe.addText(N), fe.endScope());
      }
      function rr(N, B) {
        let j = 1;
        const ee = B.length - 1;
        for (; j <= ee; ) {
          if (!N._emit[j]) {
            j++;
            continue;
          }
          const ge = we.classNameAliases[N[j]] || N[j], De = B[j];
          ge ? Ce(De, ge) : (oe = De, Ie(), oe = ""), j++;
        }
      }
      function or(N, B) {
        return N.scope && typeof N.scope == "string" && fe.openNode(we.classNameAliases[N.scope] || N.scope), N.beginScope && (N.beginScope._wrap ? (Ce(oe, we.classNameAliases[N.beginScope._wrap] || N.beginScope._wrap), oe = "") : N.beginScope._multi && (rr(N.beginScope, B), oe = "")), G = Object.create(N, { parent: { value: G } }), G;
      }
      function sr(N, B, j) {
        let ee = g(N.endRe, j);
        if (ee) {
          if (N["on:end"]) {
            const ge = new n(N);
            N["on:end"](B, ge), ge.isMatchIgnored && (ee = !1);
          }
          if (ee) {
            for (; N.endsParent && N.parent; )
              N = N.parent;
            return N;
          }
        }
        if (N.endsWithParent)
          return sr(N.parent, B, j);
      }
      function ec(N) {
        return G.matcher.regexIndex === 0 ? (oe += N[0], 1) : (xn = !0, 0);
      }
      function nc(N) {
        const B = N[0], j = N.rule, ee = new n(j), ge = [j.__beforeBegin, j["on:begin"]];
        for (const De of ge)
          if (De && (De(N, ee), ee.isMatchIgnored))
            return ec(B);
        return j.skip ? oe += B : (j.excludeBegin && (oe += B), ve(), !j.returnBegin && !j.excludeBegin && (oe = B)), or(j, N), j.returnBegin ? 0 : B.length;
      }
      function tc(N) {
        const B = N[0], j = z.substring(N.index), ee = sr(G, N, j);
        if (!ee)
          return Xt;
        const ge = G;
        G.endScope && G.endScope._wrap ? (ve(), Ce(B, G.endScope._wrap)) : G.endScope && G.endScope._multi ? (ve(), rr(G.endScope, N)) : ge.skip ? oe += B : (ge.returnEnd || ge.excludeEnd || (oe += B), ve(), ge.excludeEnd && (oe = B));
        do
          G.scope && fe.closeNode(), !G.skip && !G.subLanguage && (on += G.relevance), G = G.parent;
        while (G !== ee.parent);
        return ee.starts && or(ee.starts, N), ge.returnEnd ? 0 : B.length;
      }
      function rc() {
        const N = [];
        for (let B = G; B !== we; B = B.parent)
          B.scope && N.unshift(B.scope);
        N.forEach((B) => fe.openNode(B));
      }
      let rn = {};
      function cr(N, B) {
        const j = B && B[0];
        if (oe += N, j == null)
          return ve(), 0;
        if (rn.type === "begin" && B.type === "end" && rn.index === B.index && j === "") {
          if (oe += z.slice(B.index, B.index + 1), !se) {
            const ee = new Error(`0 width match regex (${S})`);
            throw ee.languageName = S, ee.badRule = rn.rule, ee;
          }
          return 1;
        }
        if (rn = B, B.type === "begin")
          return nc(B);
        if (B.type === "illegal" && !Y) {
          const ee = new Error('Illegal lexeme "' + j + '" for mode "' + (G.scope || "<unnamed>") + '"');
          throw ee.mode = G, ee;
        } else if (B.type === "end") {
          const ee = tc(B);
          if (ee !== Xt)
            return ee;
        }
        if (B.type === "illegal" && j === "")
          return 1;
        if (kn > 1e5 && kn > B.index * 3)
          throw new Error("potential infinite loop, way more iterations than matches");
        return oe += j, j.length;
      }
      const we = Ne(S);
      if (!we)
        throw Fe(ce.replace("{}", S)), new Error('Unknown language: "' + S + '"');
      const oc = Os(we);
      let vn = "", G = te || oc;
      const ir = {}, fe = new L.__emitter(L);
      rc();
      let oe = "", on = 0, Oe = 0, kn = 0, xn = !1;
      try {
        if (we.__emitTokens)
          we.__emitTokens(z, fe);
        else {
          for (G.matcher.considerAll(); ; ) {
            kn++, xn ? xn = !1 : G.matcher.considerAll(), G.matcher.lastIndex = Oe;
            const N = G.matcher.exec(z);
            if (!N) break;
            const B = z.substring(Oe, N.index), j = cr(B, N);
            Oe = N.index + j;
          }
          cr(z.substring(Oe));
        }
        return fe.finalize(), vn = fe.toHTML(), {
          language: S,
          value: vn,
          relevance: on,
          illegal: !1,
          _emitter: fe,
          _top: G
        };
      } catch (N) {
        if (N.message && N.message.includes("Illegal"))
          return {
            language: S,
            value: gn(z),
            illegal: !0,
            relevance: 0,
            _illegalBy: {
              message: N.message,
              index: Oe,
              context: z.slice(Oe - 100, Oe + 100),
              mode: N.mode,
              resultSoFar: vn
            },
            _emitter: fe
          };
        if (se)
          return {
            language: S,
            value: gn(z),
            illegal: !1,
            relevance: 0,
            errorRaised: N,
            _emitter: fe,
            _top: G
          };
        throw N;
      }
    }
    function _n(S) {
      const z = {
        value: gn(S),
        illegal: !1,
        relevance: 0,
        _top: F,
        _emitter: new L.__emitter(L)
      };
      return z._emitter.addText(S), z;
    }
    function mn(S, z) {
      z = z || L.languages || Object.keys(A);
      const Y = _n(S), te = z.filter(Ne).filter(tr).map(
        (ve) => Ve(ve, S, !1)
      );
      te.unshift(Y);
      const le = te.sort((ve, Ce) => {
        if (ve.relevance !== Ce.relevance) return Ce.relevance - ve.relevance;
        if (ve.language && Ce.language) {
          if (Ne(ve.language).supersetOf === Ce.language)
            return 1;
          if (Ne(Ce.language).supersetOf === ve.language)
            return -1;
        }
        return 0;
      }), [Ae, Ie] = le, tn = Ae;
      return tn.secondBest = Ie, tn;
    }
    function Us(S, z, Y) {
      const te = z && T[z] || Y;
      S.classList.add("hljs"), S.classList.add(`language-${te}`);
    }
    function bn(S) {
      let z = null;
      const Y = ue(S);
      if (U(Y)) return;
      if (nn(
        "before:highlightElement",
        { el: S, language: Y }
      ), S.dataset.highlighted) {
        console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", S);
        return;
      }
      if (S.children.length > 0 && (L.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(S)), L.throwUnescapedHTML))
        throw new zs(
          "One of your code blocks includes unescaped HTML.",
          S.innerHTML
        );
      z = S;
      const te = z.textContent, le = Y ? ie(te, { language: Y, ignoreIllegals: !0 }) : mn(te);
      S.innerHTML = le.value, S.dataset.highlighted = "yes", Us(S, Y, le.language), S.result = {
        language: le.language,
        // TODO: remove with version 11.0
        re: le.relevance,
        relevance: le.relevance
      }, le.secondBest && (S.secondBest = {
        language: le.secondBest.language,
        relevance: le.secondBest.relevance
      }), nn("after:highlightElement", { el: S, result: le, text: te });
    }
    function Hs(S) {
      L = Jt(L, S);
    }
    const Gs = () => {
      en(), Pe("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
    };
    function Vs() {
      en(), Pe("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
    }
    let er = !1;
    function en() {
      if (document.readyState === "loading") {
        er = !0;
        return;
      }
      document.querySelectorAll(L.cssSelector).forEach(bn);
    }
    function Zs() {
      er && en();
    }
    typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", Zs, !1);
    function js(S, z) {
      let Y = null;
      try {
        Y = z(p);
      } catch (te) {
        if (Fe("Language definition for '{}' could not be registered.".replace("{}", S)), se)
          Fe(te);
        else
          throw te;
        Y = F;
      }
      Y.name || (Y.name = S), A[S] = Y, Y.rawDefinition = z.bind(null, p), Y.aliases && nr(Y.aliases, { languageName: S });
    }
    function Ks(S) {
      delete A[S];
      for (const z of Object.keys(T))
        T[z] === S && delete T[z];
    }
    function Ws() {
      return Object.keys(A);
    }
    function Ne(S) {
      return S = (S || "").toLowerCase(), A[S] || A[T[S]];
    }
    function nr(S, { languageName: z }) {
      typeof S == "string" && (S = [S]), S.forEach((Y) => {
        T[Y.toLowerCase()] = z;
      });
    }
    function tr(S) {
      const z = Ne(S);
      return z && !z.disableAutodetect;
    }
    function Ys(S) {
      S["before:highlightBlock"] && !S["before:highlightElement"] && (S["before:highlightElement"] = (z) => {
        S["before:highlightBlock"](
          Object.assign({ block: z.el }, z)
        );
      }), S["after:highlightBlock"] && !S["after:highlightElement"] && (S["after:highlightElement"] = (z) => {
        S["after:highlightBlock"](
          Object.assign({ block: z.el }, z)
        );
      });
    }
    function Js(S) {
      Ys(S), H.push(S);
    }
    function Xs(S) {
      const z = H.indexOf(S);
      z !== -1 && H.splice(z, 1);
    }
    function nn(S, z) {
      const Y = S;
      H.forEach(function(te) {
        te[Y] && te[Y](z);
      });
    }
    function Qs(S) {
      return Pe("10.7.0", "highlightBlock will be removed entirely in v12.0"), Pe("10.7.0", "Please use highlightElement now."), bn(S);
    }
    Object.assign(p, {
      highlight: ie,
      highlightAuto: mn,
      highlightAll: en,
      highlightElement: bn,
      // TODO: Remove with v12 API
      highlightBlock: Qs,
      configure: Hs,
      initHighlighting: Gs,
      initHighlightingOnLoad: Vs,
      registerLanguage: js,
      unregisterLanguage: Ks,
      listLanguages: Ws,
      getLanguage: Ne,
      registerAliases: nr,
      autoDetection: tr,
      inherit: Jt,
      addPlugin: Js,
      removePlugin: Xs
    }), p.debugMode = function() {
      se = !1;
    }, p.safeMode = function() {
      se = !0;
    }, p.versionString = Ps, p.regex = {
      concat: v,
      lookahead: d,
      either: b,
      optional: _,
      anyNumberOfTimes: h
    };
    for (const S in Xe)
      typeof Xe[S] == "object" && c(Xe[S]);
    return Object.assign(p, Xe), p;
  }, ze = Qt({});
  return ze.newInstance = () => Qt({}), En = ze, ze.HighlightJS = ze, ze.default = ze, En;
}
var Bc = /* @__PURE__ */ Oc();
const Te = /* @__PURE__ */ Ot(Bc), dr = "[A-Za-z$_][0-9A-Za-z$_]*", Pc = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], zc = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], Ho = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], Go = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], Vo = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], $c = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], Uc = [].concat(
  Vo,
  Ho,
  Go
);
function Zo(c) {
  const n = c.regex, o = (Z, { after: X }) => {
    const O = "</" + Z[0].slice(1);
    return Z.input.indexOf(O, X) !== -1;
  }, e = dr, t = {
    begin: "<>",
    end: "</>"
  }, r = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (Z, X) => {
      const O = Z[0].length + Z.index, ae = Z.input[O];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        ae === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        ae === ","
      ) {
        X.ignoreMatch();
        return;
      }
      ae === ">" && (o(Z, { after: O }) || X.ignoreMatch());
      let de;
      const Ee = Z.input.substring(O);
      if (de = Ee.match(/^\s*=/)) {
        X.ignoreMatch();
        return;
      }
      if ((de = Ee.match(/^\s+extends\s+/)) && de.index === 0) {
        X.ignoreMatch();
        return;
      }
    }
  }, i = {
    $pattern: dr,
    keyword: Pc,
    literal: zc,
    built_in: Uc,
    "variable.language": $c
  }, a = "[0-9](_?[0-9])*", l = `\\.(${a})`, f = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", u = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${f})((${l})|\\.)?|(${l}))[eE][+-]?(${a})\\b` },
      { begin: `\\b(${f})\\b((${l})\\b|\\.)?|(${l})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, d = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: i,
    contains: []
    // defined later
  }, h = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        c.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "xml"
    }
  }, _ = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        c.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "css"
    }
  }, v = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        c.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "graphql"
    }
  }, E = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      c.BACKSLASH_ESCAPE,
      d
    ]
  }, x = {
    className: "comment",
    variants: [
      c.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: e + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      c.C_BLOCK_COMMENT_MODE,
      c.C_LINE_COMMENT_MODE
    ]
  }, g = [
    c.APOS_STRING_MODE,
    c.QUOTE_STRING_MODE,
    h,
    _,
    v,
    E,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    u
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  d.contains = g.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: i,
    contains: [
      "self"
    ].concat(g)
  });
  const m = [].concat(x, d.contains), k = m.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: i,
      contains: ["self"].concat(m)
    }
  ]), y = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: i,
    contains: k
  }, I = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          e,
          /\s+/,
          /extends/,
          /\s+/,
          n.concat(e, "(", n.concat(/\./, e), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          e
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, w = {
    relevance: 0,
    match: n.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...Ho,
        ...Go
      ]
    }
  }, D = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, R = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          e,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [y],
    illegal: /%/
  }, q = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function V(Z) {
    return n.concat("(?!", Z.join("|"), ")");
  }
  const ne = {
    match: n.concat(
      /\b/,
      V([
        ...Vo,
        "super",
        "import"
      ]),
      e,
      n.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, C = {
    begin: n.concat(/\./, n.lookahead(
      n.concat(e, /(?![0-9A-Za-z$_(])/)
    )),
    end: e,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, M = {
    match: [
      /get|set/,
      /\s+/,
      e,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      y
    ]
  }, $ = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + c.UNDERSCORE_IDENT_RE + ")\\s*=>", J = {
    match: [
      /const|var|let/,
      /\s+/,
      e,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      n.lookahead($)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      y
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: i,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: k, CLASS_REFERENCE: w },
    illegal: /#(?![$_A-z])/,
    contains: [
      c.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      D,
      c.APOS_STRING_MODE,
      c.QUOTE_STRING_MODE,
      h,
      _,
      v,
      E,
      x,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      u,
      w,
      {
        className: "attr",
        begin: e + n.lookahead(":"),
        relevance: 0
      },
      J,
      {
        // "value" container
        begin: "(" + c.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          x,
          c.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: $,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: c.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: i,
                    contains: k
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: t.begin, end: t.end },
              { match: r },
              {
                begin: s.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": s.isTrulyOpeningTag,
                end: s.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: s.begin,
                end: s.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      R,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + c.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          y,
          c.inherit(c.TITLE_MODE, { begin: e, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      C,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + e,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [y]
      },
      ne,
      q,
      I,
      M,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function jo(c) {
  const n = c.regex, o = n.concat(/[\p{L}_]/u, n.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), e = /[\p{L}0-9._:-]+/u, t = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, r = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, s = c.inherit(r, {
    begin: /\(/,
    end: /\)/
  }), i = c.inherit(c.APOS_STRING_MODE, { className: "string" }), a = c.inherit(c.QUOTE_STRING_MODE, { className: "string" }), l = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: e,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [t]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [t]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          r,
          a,
          i,
          s,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  r,
                  s,
                  a,
                  i
                ]
              }
            ]
          }
        ]
      },
      c.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      t,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              a
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [l],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [l],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: n.concat(
          /</,
          n.lookahead(n.concat(
            o,
            // <tag/>
            // <tag>
            // <tag ...
            n.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: o,
            relevance: 0,
            starts: l
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: n.concat(
          /<\//,
          n.lookahead(n.concat(
            o,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: o,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
const pn = (c, n) => {
  const o = c.__vccOpts || c;
  for (const [e, t] of n)
    o[e] = t;
  return o;
}, Hc = {}, Gc = { class: "chat-button" };
function Vc(c, n) {
  return P(), W("button", Gc, [
    qe(c.$slots, "default")
  ]);
}
const Zc = /* @__PURE__ */ pn(Hc, [["render", Vc]]), jc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function Kc(c, n) {
  return P(), W("svg", jc, n[0] || (n[0] = [
    re("path", {
      fill: "currentColor",
      d: "M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12z"
    }, null, -1)
  ]));
}
const Wc = { name: "mdi-close", render: Kc };
function Bt() {
  return Lo(Po);
}
function Je() {
  return {
    options: Lo(zo)
  };
}
function dn() {
  const { options: c } = Je(), n = (c == null ? void 0 : c.defaultLanguage) ?? "en";
  function o(t) {
    var s, i;
    const r = (i = (s = c == null ? void 0 : c.i18n) == null ? void 0 : s[n]) == null ? void 0 : i[t];
    return ic(r) ? r.value : r ?? t;
  }
  function e(t) {
    var r, s;
    return !!((s = (r = c == null ? void 0 : c.i18n) == null ? void 0 : r[n]) != null && s[t]);
  }
  return { t: o, te: e };
}
const Yc = { class: "chat-get-started" }, Jc = /* @__PURE__ */ ye({
  __name: "GetStarted",
  setup(c) {
    const { t: n } = dn();
    return (o, e) => (P(), W("div", Yc, [
      ke(Zc, {
        onClick: e[0] || (e[0] = (t) => o.$emit("click:button"))
      }, {
        default: Me(() => [
          qt(He(K(n)("getStarted")), 1)
        ]),
        _: 1
      })
    ]));
  }
}), Xc = {}, Qc = { class: "chat-powered-by" };
function ei(c, n) {
  return P(), W("div", Qc, n[0] || (n[0] = [
    qt(" Powered by "),
    re("a", { href: "https://n8n.io?utm_source=n8n-external&utm_medium=widget-powered-by" }, "n8n", -1)
  ]));
}
const ni = /* @__PURE__ */ pn(Xc, [["render", ei]]), ti = { class: "chat-get-started-footer" }, ri = { key: 0 }, oi = /* @__PURE__ */ ye({
  __name: "GetStartedFooter",
  setup(c) {
    const { t: n, te: o } = dn();
    return (e, t) => (P(), W("div", ti, [
      K(o)("footer") ? (P(), W("div", ri, He(K(n)("footer")), 1)) : xe("", !0),
      ke(ni)
    ]));
  }
});
function si(c) {
  return ac() ? (lc(c), !0) : !1;
}
function ci() {
  const c = /* @__PURE__ */ new Set(), n = (t) => {
    c.delete(t);
  };
  return {
    on: (t) => {
      c.add(t);
      const r = () => n(t);
      return si(r), {
        off: r
      };
    },
    off: n,
    trigger: (...t) => Promise.all(Array.from(c).map((r) => r(...t)))
  };
}
const ii = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const ai = (c, n) => Object.prototype.hasOwnProperty.call(c, n), li = ii ? window.document : void 0, ui = {
  multiple: !0,
  accept: "*",
  reset: !1,
  directory: !1
};
function fi(c = {}) {
  const {
    document: n = li
  } = c, o = _e(null), { on: e, trigger: t } = ci();
  let r;
  n && (r = n.createElement("input"), r.type = "file", r.onchange = (a) => {
    const l = a.target;
    o.value = l.files, t(o.value);
  });
  const s = () => {
    o.value = null, r && r.value && (r.value = "", t(null));
  }, i = (a) => {
    if (!r)
      return;
    const l = {
      ...ui,
      ...c,
      ...a
    };
    r.multiple = l.multiple, r.accept = l.accept, r.webkitdirectory = l.directory, ai(l, "capture") && (r.capture = l.capture), l.reset && s(), r.click();
  };
  return {
    files: uc(o),
    open: i,
    reset: s,
    onChange: e
  };
}
const hi = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function pi(c, n) {
  return P(), W("svg", hi, n[0] || (n[0] = [
    re("path", {
      fill: "currentColor",
      d: "M16.5 6v11.5a4 4 0 0 1-4 4a4 4 0 0 1-4-4V5A2.5 2.5 0 0 1 11 2.5A2.5 2.5 0 0 1 13.5 5v10.5a1 1 0 0 1-1 1a1 1 0 0 1-1-1V6H10v9.5a2.5 2.5 0 0 0 2.5 2.5a2.5 2.5 0 0 0 2.5-2.5V5a4 4 0 0 0-4-4a4 4 0 0 0-4 4v12.5a5.5 5.5 0 0 0 5.5 5.5a5.5 5.5 0 0 0 5.5-5.5V6z"
    }, null, -1)
  ]));
}
const di = { name: "mdi-paperclip", render: pi }, gi = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function _i(c, n) {
  return P(), W("svg", gi, n[0] || (n[0] = [
    re("path", {
      fill: "currentColor",
      d: "m2 21l21-9L2 3v7l15 2l-15 2z"
    }, null, -1)
  ]));
}
const mi = { name: "mdi-send", render: _i }, bi = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function vi(c, n) {
  return P(), W("svg", bi, n[0] || (n[0] = [
    re("path", {
      fill: "currentColor",
      d: "M20 6.91L17.09 4L12 9.09L6.91 4L4 6.91L9.09 12L4 17.09L6.91 20L12 14.91L17.09 20L20 17.09L14.91 12z"
    }, null, -1)
  ]));
}
const ki = { name: "mdi-closeThick", render: vi }, xi = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function yi(c, n) {
  return P(), W("svg", xi, n[0] || (n[0] = [
    re("path", {
      fill: "currentColor",
      d: "M13 9h5.5L13 3.5zM6 2h8l6 6v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4c0-1.11.89-2 2-2m0 18h12v-8l-4 4l-2-2zM8 9a2 2 0 0 0-2 2a2 2 0 0 0 2 2a2 2 0 0 0 2-2a2 2 0 0 0-2-2"
    }, null, -1)
  ]));
}
const Ei = { name: "mdi-fileImage", render: yi }, Ai = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function Ci(c, n) {
  return P(), W("svg", Ai, n[0] || (n[0] = [
    re("path", {
      fill: "currentColor",
      d: "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8zm-1 11h-2v5a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2c.4 0 .7.1 1 .3V11h3zm0-4V3.5L18.5 9z"
    }, null, -1)
  ]));
}
const wi = { name: "mdi-fileMusic", render: Ci }, Si = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function Ri(c, n) {
  return P(), W("svg", Si, n[0] || (n[0] = [
    re("path", {
      fill: "currentColor",
      d: "M13 9h5.5L13 3.5zM6 2h8l6 6v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4c0-1.11.89-2 2-2m9 16v-2H6v2zm3-4v-2H6v2z"
    }, null, -1)
  ]));
}
const gr = { name: "mdi-fileText", render: Ri }, Di = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function Ti(c, n) {
  return P(), W("svg", Di, n[0] || (n[0] = [
    re("path", {
      fill: "currentColor",
      d: "M13 9h5.5L13 3.5zM6 2h8l6 6v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4c0-1.11.89-2 2-2m11 17v-6l-3 2.2V13H7v6h7v-2.2z"
    }, null, -1)
  ]));
}
const Mi = { name: "mdi-fileVideo", render: Ti }, Ni = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function Ii(c, n) {
  return P(), W("svg", Ni, n[0] || (n[0] = [
    re("path", {
      fill: "currentColor",
      d: "M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"
    }, null, -1)
  ]));
}
const Li = { name: "mdi-openInNew", render: Ii }, qi = { class: "chat-file-name" }, Fi = /* @__PURE__ */ ye({
  __name: "ChatFile",
  props: {
    file: {},
    isRemovable: { type: Boolean },
    isPreviewable: { type: Boolean }
  },
  emits: ["remove"],
  setup(c, { emit: n }) {
    const o = c, e = n, t = {
      document: gr,
      audio: wi,
      image: Ei,
      video: Mi
    }, r = me(() => {
      var l;
      const a = (l = o.file) == null ? void 0 : l.type.split("/")[0];
      return t[a] || gr;
    });
    function s() {
      o.isPreviewable && window.open(URL.createObjectURL(o.file));
    }
    function i() {
      e("remove", o.file);
    }
    return (a, l) => (P(), W("div", {
      class: "chat-file",
      onClick: s
    }, [
      ke(K(r)),
      re("p", qi, He(a.file.name), 1),
      a.isRemovable ? (P(), W("span", {
        key: 0,
        class: "chat-file-delete",
        onClick: qo(i, ["stop"])
      }, [
        ke(K(ki))
      ])) : a.isPreviewable ? (P(), pe(K(Li), {
        key: 1,
        class: "chat-file-preview"
      })) : xe("", !0)
    ]));
  }
}), Ko = /* @__PURE__ */ pn(Fi, [["__scopeId", "data-v-e0d57af7"]]), Oi = { class: "chat-inputs" }, Bi = {
  key: 0,
  class: "chat-input-left-panel"
}, Pi = ["disabled", "placeholder"], zi = { class: "chat-inputs-controls" }, $i = ["disabled"], Ui = ["disabled"], Hi = {
  key: 0,
  class: "chat-files"
}, Gi = /* @__PURE__ */ ye({
  __name: "Input",
  props: {
    placeholder: { default: "inputPlaceholder" }
  },
  emits: ["arrowKeyDown"],
  setup(c, { emit: n }) {
    const o = c, { t: e } = dn(), t = n, { options: r } = Je(), s = Bt(), { waitingForResponse: i } = s, a = _e(null), l = _e(null), f = _e(""), u = _e(!1), d = _e(null), h = me(() => {
      var M;
      return f.value === "" || K(i) || ((M = r.disabled) == null ? void 0 : M.value) === !0;
    }), _ = me(() => {
      var M;
      return ((M = r.disabled) == null ? void 0 : M.value) === !0;
    }), v = me(
      () => {
        var M;
        return E.value && K(i) && !((M = r.disabled) != null && M.value);
      }
    ), E = me(() => K(r.allowFileUploads) === !0), b = me(() => K(r.allowedFilesMimeTypes)), x = me(() => ({
      "--controls-count": E.value ? 2 : 1
    })), {
      open: g,
      reset: m,
      onChange: k
    } = fi({
      multiple: !0,
      reset: !1
    });
    k((M) => {
      if (!M) return;
      const $ = new DataTransfer();
      if (a.value)
        for (let J = 0; J < a.value.length; J++)
          $.items.add(a.value[J]);
      for (let J = 0; J < M.length; J++)
        $.items.add(M[J]);
      a.value = $.files;
    }), Ge(() => {
      be.on("focusInput", I), be.on("blurInput", y), be.on("setInputValue", w), l.value && (d.value = new ResizeObserver((M) => {
        for (const $ of M)
          $.target === l.value && C();
      }), d.value.observe(l.value));
    }), fc(() => {
      be.off("focusInput", I), be.off("blurInput", y), be.off("setInputValue", w), d.value && (d.value.disconnect(), d.value = null);
    });
    function y() {
      l.value && l.value.blur();
    }
    function I() {
      l.value && l.value.focus();
    }
    function w(M) {
      f.value = M, I();
    }
    async function D(M) {
      if (M.preventDefault(), h.value)
        return;
      const $ = f.value;
      f.value = "", u.value = !0, await s.sendMessage($, Array.from(a.value ?? [])), u.value = !1, m(), a.value = null;
    }
    async function R(M) {
      M.shiftKey || (await D(M), C());
    }
    function q(M) {
      if (!a.value) return;
      const $ = new DataTransfer();
      for (let J = 0; J < a.value.length; J++) {
        const Z = a.value[J];
        M.name !== Z.name && $.items.add(Z);
      }
      m(), a.value = $.files;
    }
    function V(M) {
      (M.key === "ArrowUp" || M.key === "ArrowDown") && (M.preventDefault(), t("arrowKeyDown", {
        key: M.key,
        currentInputValue: f.value
      }));
    }
    function ne() {
      v.value || g({ accept: K(b) });
    }
    function C() {
      const M = l.value;
      if (!M) return;
      M.style.height = "var(--chat--textarea--height)";
      const $ = Math.min(M.scrollHeight, 480);
      M.style.height = `${$}px`;
    }
    return (M, $) => {
      var J;
      return P(), W("div", {
        class: "chat-input",
        style: hc(x.value),
        onKeydown: qo(V, ["stop"])
      }, [
        re("div", Oi, [
          M.$slots.leftPanel ? (P(), W("div", Bi, [
            qe(M.$slots, "leftPanel", {}, void 0, !0)
          ])) : xe("", !0),
          Fo(re("textarea", {
            ref_key: "chatTextArea",
            ref: l,
            "onUpdate:modelValue": $[0] || ($[0] = (Z) => f.value = Z),
            "data-test-id": "chat-input",
            disabled: _.value,
            placeholder: K(e)(o.placeholder),
            onKeydown: pc(R, ["enter"]),
            onInput: C,
            onMousedown: C,
            onFocus: C
          }, null, 40, Pi), [
            [dc, f.value]
          ]),
          re("div", zi, [
            E.value ? (P(), W("button", {
              key: 0,
              disabled: v.value,
              class: "chat-input-file-button",
              "data-test-id": "chat-attach-file-button",
              onClick: ne
            }, [
              ke(K(di), {
                height: "24",
                width: "24"
              })
            ], 8, $i)) : xe("", !0),
            re("button", {
              disabled: h.value,
              class: "chat-input-send-button",
              onClick: D
            }, [
              ke(K(mi), {
                height: "24",
                width: "24"
              })
            ], 8, Ui)
          ])
        ]),
        (J = a.value) != null && J.length && !u.value ? (P(), W("div", Hi, [
          (P(!0), W(un, null, fn(a.value, (Z) => (P(), pe(Ko, {
            key: Z.name,
            file: Z,
            "is-removable": !0,
            "is-previewable": !0,
            onRemove: q
          }, null, 8, ["file"]))), 128))
        ])) : xe("", !0)
      ], 36);
    };
  }
}), Vi = /* @__PURE__ */ pn(Gi, [["__scopeId", "data-v-31e29ba2"]]), Zi = { class: "chat-layout" }, ji = {
  key: 0,
  class: "chat-header"
}, Ki = {
  key: 2,
  class: "chat-footer"
}, Wi = /* @__PURE__ */ ye({
  __name: "Layout",
  setup(c) {
    const n = _e(null);
    function o() {
      const e = n.value;
      e && (e.scrollTop = e.scrollHeight);
    }
    return Ge(() => {
      be.on("scrollToBottom", o), window.addEventListener("resize", o);
    }), gc(() => {
      be.off("scrollToBottom", o), window.removeEventListener("resize", o);
    }), (e, t) => (P(), W("main", Zi, [
      e.$slots.header ? (P(), W("div", ji, [
        qe(e.$slots, "header")
      ])) : xe("", !0),
      e.$slots.default ? (P(), W("div", {
        key: 1,
        ref_key: "chatBodyRef",
        ref: n,
        class: "chat-body"
      }, [
        qe(e.$slots, "default")
      ], 512)) : xe("", !0),
      e.$slots.footer ? (P(), W("div", Ki, [
        qe(e.$slots, "footer")
      ])) : xe("", !0)
    ]));
  }
});
function Yi(c) {
  const n = c.regex, o = {}, e = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [o]
      }
      // default values
    ]
  };
  Object.assign(o, {
    className: "variable",
    variants: [
      { begin: n.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      e
    ]
  });
  const t = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [c.BACKSLASH_ESCAPE]
  }, r = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      c.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, s = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      c.BACKSLASH_ESCAPE,
      o,
      t
    ]
  };
  t.contains.push(s);
  const i = {
    match: /\\"/
  }, a = {
    className: "string",
    begin: /'/,
    end: /'/
  }, l = {
    match: /\\'/
  }, f = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      c.NUMBER_MODE,
      o
    ]
  }, u = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], d = c.SHEBANG({
    binary: `(${u.join("|")})`,
    relevance: 10
  }), h = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: !0,
    contains: [c.inherit(c.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, _ = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function",
    "select"
  ], v = [
    "true",
    "false"
  ], E = { match: /(\/[a-z._-]+)+/ }, b = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], x = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], g = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], m = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: _,
      literal: v,
      built_in: [
        ...b,
        ...x,
        // Shell modifiers
        "set",
        "shopt",
        ...g,
        ...m
      ]
    },
    contains: [
      d,
      // to catch known shells and boost relevancy
      c.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      h,
      f,
      c.HASH_COMMENT_MODE,
      r,
      E,
      s,
      i,
      a,
      l,
      o
    ]
  };
}
function Ji(c) {
  const n = c.regex, o = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), e = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], i = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: e,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, a = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, l = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: i,
    illegal: /#/
  }, f = {
    begin: /\{\{/,
    relevance: 0
  }, u = {
    className: "string",
    contains: [c.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          c.BACKSLASH_ESCAPE,
          a
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          c.BACKSLASH_ESCAPE,
          a
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          c.BACKSLASH_ESCAPE,
          a,
          f,
          l
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          c.BACKSLASH_ESCAPE,
          a,
          f,
          l
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          c.BACKSLASH_ESCAPE,
          f,
          l
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          c.BACKSLASH_ESCAPE,
          f,
          l
        ]
      },
      c.APOS_STRING_MODE,
      c.QUOTE_STRING_MODE
    ]
  }, d = "[0-9](_?[0-9])*", h = `(\\b(${d}))?\\.(${d})|\\b(${d})\\.`, _ = `\\b|${e.join("|")}`, v = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${d})|(${h}))[eE][+-]?(${d})[jJ]?(?=${_})`
      },
      {
        begin: `(${h})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${_})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${_})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${_})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${_})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${d})[jJ](?=${_})`
      }
    ]
  }, E = {
    className: "comment",
    begin: n.lookahead(/# type:/),
    end: /$/,
    keywords: i,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: !0
      }
    ]
  }, b = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: !0
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: i,
        contains: [
          "self",
          a,
          v,
          u,
          c.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return l.contains = [
    u,
    v,
    a
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: !0,
    keywords: i,
    illegal: /(<\/|\?)|=>/,
    contains: [
      a,
      v,
      {
        // very common convention
        begin: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      u,
      E,
      c.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          o
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [b]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              o,
              /\s*/,
              /\(\s*/,
              o,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              o
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          v,
          b,
          u
        ]
      }
    ]
  };
}
const hn = "[A-Za-z$_][0-9A-Za-z$_]*", Wo = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], Yo = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], Jo = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], Xo = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], Qo = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], es = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], ns = [].concat(
  Qo,
  Jo,
  Xo
);
function Xi(c) {
  const n = c.regex, o = (Z, { after: X }) => {
    const O = "</" + Z[0].slice(1);
    return Z.input.indexOf(O, X) !== -1;
  }, e = hn, t = {
    begin: "<>",
    end: "</>"
  }, r = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (Z, X) => {
      const O = Z[0].length + Z.index, ae = Z.input[O];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        ae === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        ae === ","
      ) {
        X.ignoreMatch();
        return;
      }
      ae === ">" && (o(Z, { after: O }) || X.ignoreMatch());
      let de;
      const Ee = Z.input.substring(O);
      if (de = Ee.match(/^\s*=/)) {
        X.ignoreMatch();
        return;
      }
      if ((de = Ee.match(/^\s+extends\s+/)) && de.index === 0) {
        X.ignoreMatch();
        return;
      }
    }
  }, i = {
    $pattern: hn,
    keyword: Wo,
    literal: Yo,
    built_in: ns,
    "variable.language": es
  }, a = "[0-9](_?[0-9])*", l = `\\.(${a})`, f = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", u = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${f})((${l})|\\.)?|(${l}))[eE][+-]?(${a})\\b` },
      { begin: `\\b(${f})\\b((${l})\\b|\\.)?|(${l})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, d = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: i,
    contains: []
    // defined later
  }, h = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        c.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "xml"
    }
  }, _ = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        c.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "css"
    }
  }, v = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        c.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "graphql"
    }
  }, E = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      c.BACKSLASH_ESCAPE,
      d
    ]
  }, x = {
    className: "comment",
    variants: [
      c.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: e + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      c.C_BLOCK_COMMENT_MODE,
      c.C_LINE_COMMENT_MODE
    ]
  }, g = [
    c.APOS_STRING_MODE,
    c.QUOTE_STRING_MODE,
    h,
    _,
    v,
    E,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    u
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  d.contains = g.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: i,
    contains: [
      "self"
    ].concat(g)
  });
  const m = [].concat(x, d.contains), k = m.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: i,
      contains: ["self"].concat(m)
    }
  ]), y = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: i,
    contains: k
  }, I = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          e,
          /\s+/,
          /extends/,
          /\s+/,
          n.concat(e, "(", n.concat(/\./, e), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          e
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, w = {
    relevance: 0,
    match: n.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...Jo,
        ...Xo
      ]
    }
  }, D = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, R = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          e,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [y],
    illegal: /%/
  }, q = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function V(Z) {
    return n.concat("(?!", Z.join("|"), ")");
  }
  const ne = {
    match: n.concat(
      /\b/,
      V([
        ...Qo,
        "super",
        "import"
      ]),
      e,
      n.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, C = {
    begin: n.concat(/\./, n.lookahead(
      n.concat(e, /(?![0-9A-Za-z$_(])/)
    )),
    end: e,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, M = {
    match: [
      /get|set/,
      /\s+/,
      e,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      y
    ]
  }, $ = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + c.UNDERSCORE_IDENT_RE + ")\\s*=>", J = {
    match: [
      /const|var|let/,
      /\s+/,
      e,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      n.lookahead($)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      y
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: i,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: k, CLASS_REFERENCE: w },
    illegal: /#(?![$_A-z])/,
    contains: [
      c.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      D,
      c.APOS_STRING_MODE,
      c.QUOTE_STRING_MODE,
      h,
      _,
      v,
      E,
      x,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      u,
      w,
      {
        className: "attr",
        begin: e + n.lookahead(":"),
        relevance: 0
      },
      J,
      {
        // "value" container
        begin: "(" + c.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          x,
          c.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: $,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: c.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: i,
                    contains: k
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: t.begin, end: t.end },
              { match: r },
              {
                begin: s.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": s.isTrulyOpeningTag,
                end: s.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: s.begin,
                end: s.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      R,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + c.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          y,
          c.inherit(c.TITLE_MODE, { begin: e, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      C,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + e,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [y]
      },
      ne,
      q,
      I,
      M,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function Qi(c) {
  const n = Xi(c), o = hn, e = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ], t = {
    beginKeywords: "namespace",
    end: /\{/,
    excludeEnd: !0,
    contains: [n.exports.CLASS_REFERENCE]
  }, r = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: !0,
    keywords: {
      keyword: "interface extends",
      built_in: e
    },
    contains: [n.exports.CLASS_REFERENCE]
  }, s = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }, i = [
    "type",
    "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override"
  ], a = {
    $pattern: hn,
    keyword: Wo.concat(i),
    literal: Yo,
    built_in: ns.concat(e),
    "variable.language": es
  }, l = {
    className: "meta",
    begin: "@" + o
  }, f = (d, h, _) => {
    const v = d.contains.findIndex((E) => E.label === h);
    if (v === -1)
      throw new Error("can not find mode to replace");
    d.contains.splice(v, 1, _);
  };
  Object.assign(n.keywords, a), n.exports.PARAMS_CONTAINS.push(l), n.contains = n.contains.concat([
    l,
    t,
    r
  ]), f(n, "shebang", c.SHEBANG()), f(n, "use_strict", s);
  const u = n.contains.find((d) => d.label === "func.def");
  return u.relevance = 0, Object.assign(n, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  }), n;
}
var An, _r;
function ea() {
  if (_r) return An;
  _r = 1;
  function c(e, t) {
    var r, s, i = e.attrs[e.attrIndex("href")][1];
    for (r = 0; r < t.length; ++r) {
      if (s = t[r], typeof s.matcher == "function") {
        if (s.matcher(i, s))
          return s;
        continue;
      }
      return s;
    }
  }
  function n(e, t, r) {
    Object.keys(r).forEach(function(s) {
      var i, a = r[s];
      s === "className" && (s = "class"), i = t[e].attrIndex(s), i < 0 ? t[e].attrPush([s, a]) : t[e].attrs[i][1] = a;
    });
  }
  function o(e, t) {
    t ? t = Array.isArray(t) ? t : [t] : t = [], Object.freeze(t);
    var r = e.renderer.rules.link_open || this.defaultRender;
    e.renderer.rules.link_open = function(s, i, a, l, f) {
      var u = c(s[i], t), d = u && u.attrs;
      return d && n(i, s, d), r(s, i, a, l, f);
    };
  }
  return o.defaultRender = function(e, t, r, s, i) {
    return i.renderToken(e, t, r);
  }, An = o, An;
}
var na = ea();
const ta = /* @__PURE__ */ Ot(na);
var Cn = {};
const ra = "Á", oa = "á", sa = "Ă", ca = "ă", ia = "∾", aa = "∿", la = "∾̳", ua = "Â", fa = "â", ha = "´", pa = "А", da = "а", ga = "Æ", _a = "æ", ma = "⁡", ba = "𝔄", va = "𝔞", ka = "À", xa = "à", ya = "ℵ", Ea = "ℵ", Aa = "Α", Ca = "α", wa = "Ā", Sa = "ā", Ra = "⨿", Da = "&", Ta = "&", Ma = "⩕", Na = "⩓", Ia = "∧", La = "⩜", qa = "⩘", Fa = "⩚", Oa = "∠", Ba = "⦤", Pa = "∠", za = "⦨", $a = "⦩", Ua = "⦪", Ha = "⦫", Ga = "⦬", Va = "⦭", Za = "⦮", ja = "⦯", Ka = "∡", Wa = "∟", Ya = "⊾", Ja = "⦝", Xa = "∢", Qa = "Å", el = "⍼", nl = "Ą", tl = "ą", rl = "𝔸", ol = "𝕒", sl = "⩯", cl = "≈", il = "⩰", al = "≊", ll = "≋", ul = "'", fl = "⁡", hl = "≈", pl = "≊", dl = "Å", gl = "å", _l = "𝒜", ml = "𝒶", bl = "≔", vl = "*", kl = "≈", xl = "≍", yl = "Ã", El = "ã", Al = "Ä", Cl = "ä", wl = "∳", Sl = "⨑", Rl = "≌", Dl = "϶", Tl = "‵", Ml = "∽", Nl = "⋍", Il = "∖", Ll = "⫧", ql = "⊽", Fl = "⌅", Ol = "⌆", Bl = "⌅", Pl = "⎵", zl = "⎶", $l = "≌", Ul = "Б", Hl = "б", Gl = "„", Vl = "∵", Zl = "∵", jl = "∵", Kl = "⦰", Wl = "϶", Yl = "ℬ", Jl = "ℬ", Xl = "Β", Ql = "β", eu = "ℶ", nu = "≬", tu = "𝔅", ru = "𝔟", ou = "⋂", su = "◯", cu = "⋃", iu = "⨀", au = "⨁", lu = "⨂", uu = "⨆", fu = "★", hu = "▽", pu = "△", du = "⨄", gu = "⋁", _u = "⋀", mu = "⤍", bu = "⧫", vu = "▪", ku = "▴", xu = "▾", yu = "◂", Eu = "▸", Au = "␣", Cu = "▒", wu = "░", Su = "▓", Ru = "█", Du = "=⃥", Tu = "≡⃥", Mu = "⫭", Nu = "⌐", Iu = "𝔹", Lu = "𝕓", qu = "⊥", Fu = "⊥", Ou = "⋈", Bu = "⧉", Pu = "┐", zu = "╕", $u = "╖", Uu = "╗", Hu = "┌", Gu = "╒", Vu = "╓", Zu = "╔", ju = "─", Ku = "═", Wu = "┬", Yu = "╤", Ju = "╥", Xu = "╦", Qu = "┴", ef = "╧", nf = "╨", tf = "╩", rf = "⊟", of = "⊞", sf = "⊠", cf = "┘", af = "╛", lf = "╜", uf = "╝", ff = "└", hf = "╘", pf = "╙", df = "╚", gf = "│", _f = "║", mf = "┼", bf = "╪", vf = "╫", kf = "╬", xf = "┤", yf = "╡", Ef = "╢", Af = "╣", Cf = "├", wf = "╞", Sf = "╟", Rf = "╠", Df = "‵", Tf = "˘", Mf = "˘", Nf = "¦", If = "𝒷", Lf = "ℬ", qf = "⁏", Ff = "∽", Of = "⋍", Bf = "⧅", Pf = "\\", zf = "⟈", $f = "•", Uf = "•", Hf = "≎", Gf = "⪮", Vf = "≏", Zf = "≎", jf = "≏", Kf = "Ć", Wf = "ć", Yf = "⩄", Jf = "⩉", Xf = "⩋", Qf = "∩", eh = "⋒", nh = "⩇", th = "⩀", rh = "ⅅ", oh = "∩︀", sh = "⁁", ch = "ˇ", ih = "ℭ", ah = "⩍", lh = "Č", uh = "č", fh = "Ç", hh = "ç", ph = "Ĉ", dh = "ĉ", gh = "∰", _h = "⩌", mh = "⩐", bh = "Ċ", vh = "ċ", kh = "¸", xh = "¸", yh = "⦲", Eh = "¢", Ah = "·", Ch = "·", wh = "𝔠", Sh = "ℭ", Rh = "Ч", Dh = "ч", Th = "✓", Mh = "✓", Nh = "Χ", Ih = "χ", Lh = "ˆ", qh = "≗", Fh = "↺", Oh = "↻", Bh = "⊛", Ph = "⊚", zh = "⊝", $h = "⊙", Uh = "®", Hh = "Ⓢ", Gh = "⊖", Vh = "⊕", Zh = "⊗", jh = "○", Kh = "⧃", Wh = "≗", Yh = "⨐", Jh = "⫯", Xh = "⧂", Qh = "∲", ep = "”", np = "’", tp = "♣", rp = "♣", op = ":", sp = "∷", cp = "⩴", ip = "≔", ap = "≔", lp = ",", up = "@", fp = "∁", hp = "∘", pp = "∁", dp = "ℂ", gp = "≅", _p = "⩭", mp = "≡", bp = "∮", vp = "∯", kp = "∮", xp = "𝕔", yp = "ℂ", Ep = "∐", Ap = "∐", Cp = "©", wp = "©", Sp = "℗", Rp = "∳", Dp = "↵", Tp = "✗", Mp = "⨯", Np = "𝒞", Ip = "𝒸", Lp = "⫏", qp = "⫑", Fp = "⫐", Op = "⫒", Bp = "⋯", Pp = "⤸", zp = "⤵", $p = "⋞", Up = "⋟", Hp = "↶", Gp = "⤽", Vp = "⩈", Zp = "⩆", jp = "≍", Kp = "∪", Wp = "⋓", Yp = "⩊", Jp = "⊍", Xp = "⩅", Qp = "∪︀", ed = "↷", nd = "⤼", td = "⋞", rd = "⋟", od = "⋎", sd = "⋏", cd = "¤", id = "↶", ad = "↷", ld = "⋎", ud = "⋏", fd = "∲", hd = "∱", pd = "⌭", dd = "†", gd = "‡", _d = "ℸ", md = "↓", bd = "↡", vd = "⇓", kd = "‐", xd = "⫤", yd = "⊣", Ed = "⤏", Ad = "˝", Cd = "Ď", wd = "ď", Sd = "Д", Rd = "д", Dd = "‡", Td = "⇊", Md = "ⅅ", Nd = "ⅆ", Id = "⤑", Ld = "⩷", qd = "°", Fd = "∇", Od = "Δ", Bd = "δ", Pd = "⦱", zd = "⥿", $d = "𝔇", Ud = "𝔡", Hd = "⥥", Gd = "⇃", Vd = "⇂", Zd = "´", jd = "˙", Kd = "˝", Wd = "`", Yd = "˜", Jd = "⋄", Xd = "⋄", Qd = "⋄", eg = "♦", ng = "♦", tg = "¨", rg = "ⅆ", og = "ϝ", sg = "⋲", cg = "÷", ig = "÷", ag = "⋇", lg = "⋇", ug = "Ђ", fg = "ђ", hg = "⌞", pg = "⌍", dg = "$", gg = "𝔻", _g = "𝕕", mg = "¨", bg = "˙", vg = "⃜", kg = "≐", xg = "≑", yg = "≐", Eg = "∸", Ag = "∔", Cg = "⊡", wg = "⌆", Sg = "∯", Rg = "¨", Dg = "⇓", Tg = "⇐", Mg = "⇔", Ng = "⫤", Ig = "⟸", Lg = "⟺", qg = "⟹", Fg = "⇒", Og = "⊨", Bg = "⇑", Pg = "⇕", zg = "∥", $g = "⤓", Ug = "↓", Hg = "↓", Gg = "⇓", Vg = "⇵", Zg = "̑", jg = "⇊", Kg = "⇃", Wg = "⇂", Yg = "⥐", Jg = "⥞", Xg = "⥖", Qg = "↽", e_ = "⥟", n_ = "⥗", t_ = "⇁", r_ = "↧", o_ = "⊤", s_ = "⤐", c_ = "⌟", i_ = "⌌", a_ = "𝒟", l_ = "𝒹", u_ = "Ѕ", f_ = "ѕ", h_ = "⧶", p_ = "Đ", d_ = "đ", g_ = "⋱", __ = "▿", m_ = "▾", b_ = "⇵", v_ = "⥯", k_ = "⦦", x_ = "Џ", y_ = "џ", E_ = "⟿", A_ = "É", C_ = "é", w_ = "⩮", S_ = "Ě", R_ = "ě", D_ = "Ê", T_ = "ê", M_ = "≖", N_ = "≕", I_ = "Э", L_ = "э", q_ = "⩷", F_ = "Ė", O_ = "ė", B_ = "≑", P_ = "ⅇ", z_ = "≒", $_ = "𝔈", U_ = "𝔢", H_ = "⪚", G_ = "È", V_ = "è", Z_ = "⪖", j_ = "⪘", K_ = "⪙", W_ = "∈", Y_ = "⏧", J_ = "ℓ", X_ = "⪕", Q_ = "⪗", em = "Ē", nm = "ē", tm = "∅", rm = "∅", om = "◻", sm = "∅", cm = "▫", im = " ", am = " ", lm = " ", um = "Ŋ", fm = "ŋ", hm = " ", pm = "Ę", dm = "ę", gm = "𝔼", _m = "𝕖", mm = "⋕", bm = "⧣", vm = "⩱", km = "ε", xm = "Ε", ym = "ε", Em = "ϵ", Am = "≖", Cm = "≕", wm = "≂", Sm = "⪖", Rm = "⪕", Dm = "⩵", Tm = "=", Mm = "≂", Nm = "≟", Im = "⇌", Lm = "≡", qm = "⩸", Fm = "⧥", Om = "⥱", Bm = "≓", Pm = "ℯ", zm = "ℰ", $m = "≐", Um = "⩳", Hm = "≂", Gm = "Η", Vm = "η", Zm = "Ð", jm = "ð", Km = "Ë", Wm = "ë", Ym = "€", Jm = "!", Xm = "∃", Qm = "∃", e0 = "ℰ", n0 = "ⅇ", t0 = "ⅇ", r0 = "≒", o0 = "Ф", s0 = "ф", c0 = "♀", i0 = "ﬃ", a0 = "ﬀ", l0 = "ﬄ", u0 = "𝔉", f0 = "𝔣", h0 = "ﬁ", p0 = "◼", d0 = "▪", g0 = "fj", _0 = "♭", m0 = "ﬂ", b0 = "▱", v0 = "ƒ", k0 = "𝔽", x0 = "𝕗", y0 = "∀", E0 = "∀", A0 = "⋔", C0 = "⫙", w0 = "ℱ", S0 = "⨍", R0 = "½", D0 = "⅓", T0 = "¼", M0 = "⅕", N0 = "⅙", I0 = "⅛", L0 = "⅔", q0 = "⅖", F0 = "¾", O0 = "⅗", B0 = "⅜", P0 = "⅘", z0 = "⅚", $0 = "⅝", U0 = "⅞", H0 = "⁄", G0 = "⌢", V0 = "𝒻", Z0 = "ℱ", j0 = "ǵ", K0 = "Γ", W0 = "γ", Y0 = "Ϝ", J0 = "ϝ", X0 = "⪆", Q0 = "Ğ", eb = "ğ", nb = "Ģ", tb = "Ĝ", rb = "ĝ", ob = "Г", sb = "г", cb = "Ġ", ib = "ġ", ab = "≥", lb = "≧", ub = "⪌", fb = "⋛", hb = "≥", pb = "≧", db = "⩾", gb = "⪩", _b = "⩾", mb = "⪀", bb = "⪂", vb = "⪄", kb = "⋛︀", xb = "⪔", yb = "𝔊", Eb = "𝔤", Ab = "≫", Cb = "⋙", wb = "⋙", Sb = "ℷ", Rb = "Ѓ", Db = "ѓ", Tb = "⪥", Mb = "≷", Nb = "⪒", Ib = "⪤", Lb = "⪊", qb = "⪊", Fb = "⪈", Ob = "≩", Bb = "⪈", Pb = "≩", zb = "⋧", $b = "𝔾", Ub = "𝕘", Hb = "`", Gb = "≥", Vb = "⋛", Zb = "≧", jb = "⪢", Kb = "≷", Wb = "⩾", Yb = "≳", Jb = "𝒢", Xb = "ℊ", Qb = "≳", ev = "⪎", nv = "⪐", tv = "⪧", rv = "⩺", ov = ">", sv = ">", cv = "≫", iv = "⋗", av = "⦕", lv = "⩼", uv = "⪆", fv = "⥸", hv = "⋗", pv = "⋛", dv = "⪌", gv = "≷", _v = "≳", mv = "≩︀", bv = "≩︀", vv = "ˇ", kv = " ", xv = "½", yv = "ℋ", Ev = "Ъ", Av = "ъ", Cv = "⥈", wv = "↔", Sv = "⇔", Rv = "↭", Dv = "^", Tv = "ℏ", Mv = "Ĥ", Nv = "ĥ", Iv = "♥", Lv = "♥", qv = "…", Fv = "⊹", Ov = "𝔥", Bv = "ℌ", Pv = "ℋ", zv = "⤥", $v = "⤦", Uv = "⇿", Hv = "∻", Gv = "↩", Vv = "↪", Zv = "𝕙", jv = "ℍ", Kv = "―", Wv = "─", Yv = "𝒽", Jv = "ℋ", Xv = "ℏ", Qv = "Ħ", ek = "ħ", nk = "≎", tk = "≏", rk = "⁃", ok = "‐", sk = "Í", ck = "í", ik = "⁣", ak = "Î", lk = "î", uk = "И", fk = "и", hk = "İ", pk = "Е", dk = "е", gk = "¡", _k = "⇔", mk = "𝔦", bk = "ℑ", vk = "Ì", kk = "ì", xk = "ⅈ", yk = "⨌", Ek = "∭", Ak = "⧜", Ck = "℩", wk = "Ĳ", Sk = "ĳ", Rk = "Ī", Dk = "ī", Tk = "ℑ", Mk = "ⅈ", Nk = "ℐ", Ik = "ℑ", Lk = "ı", qk = "ℑ", Fk = "⊷", Ok = "Ƶ", Bk = "⇒", Pk = "℅", zk = "∞", $k = "⧝", Uk = "ı", Hk = "⊺", Gk = "∫", Vk = "∬", Zk = "ℤ", jk = "∫", Kk = "⊺", Wk = "⋂", Yk = "⨗", Jk = "⨼", Xk = "⁣", Qk = "⁢", ex = "Ё", nx = "ё", tx = "Į", rx = "į", ox = "𝕀", sx = "𝕚", cx = "Ι", ix = "ι", ax = "⨼", lx = "¿", ux = "𝒾", fx = "ℐ", hx = "∈", px = "⋵", dx = "⋹", gx = "⋴", _x = "⋳", mx = "∈", bx = "⁢", vx = "Ĩ", kx = "ĩ", xx = "І", yx = "і", Ex = "Ï", Ax = "ï", Cx = "Ĵ", wx = "ĵ", Sx = "Й", Rx = "й", Dx = "𝔍", Tx = "𝔧", Mx = "ȷ", Nx = "𝕁", Ix = "𝕛", Lx = "𝒥", qx = "𝒿", Fx = "Ј", Ox = "ј", Bx = "Є", Px = "є", zx = "Κ", $x = "κ", Ux = "ϰ", Hx = "Ķ", Gx = "ķ", Vx = "К", Zx = "к", jx = "𝔎", Kx = "𝔨", Wx = "ĸ", Yx = "Х", Jx = "х", Xx = "Ќ", Qx = "ќ", e1 = "𝕂", n1 = "𝕜", t1 = "𝒦", r1 = "𝓀", o1 = "⇚", s1 = "Ĺ", c1 = "ĺ", i1 = "⦴", a1 = "ℒ", l1 = "Λ", u1 = "λ", f1 = "⟨", h1 = "⟪", p1 = "⦑", d1 = "⟨", g1 = "⪅", _1 = "ℒ", m1 = "«", b1 = "⇤", v1 = "⤟", k1 = "←", x1 = "↞", y1 = "⇐", E1 = "⤝", A1 = "↩", C1 = "↫", w1 = "⤹", S1 = "⥳", R1 = "↢", D1 = "⤙", T1 = "⤛", M1 = "⪫", N1 = "⪭", I1 = "⪭︀", L1 = "⤌", q1 = "⤎", F1 = "❲", O1 = "{", B1 = "[", P1 = "⦋", z1 = "⦏", $1 = "⦍", U1 = "Ľ", H1 = "ľ", G1 = "Ļ", V1 = "ļ", Z1 = "⌈", j1 = "{", K1 = "Л", W1 = "л", Y1 = "⤶", J1 = "“", X1 = "„", Q1 = "⥧", ey = "⥋", ny = "↲", ty = "≤", ry = "≦", oy = "⟨", sy = "⇤", cy = "←", iy = "←", ay = "⇐", ly = "⇆", uy = "↢", fy = "⌈", hy = "⟦", py = "⥡", dy = "⥙", gy = "⇃", _y = "⌊", my = "↽", by = "↼", vy = "⇇", ky = "↔", xy = "↔", yy = "⇔", Ey = "⇆", Ay = "⇋", Cy = "↭", wy = "⥎", Sy = "↤", Ry = "⊣", Dy = "⥚", Ty = "⋋", My = "⧏", Ny = "⊲", Iy = "⊴", Ly = "⥑", qy = "⥠", Fy = "⥘", Oy = "↿", By = "⥒", Py = "↼", zy = "⪋", $y = "⋚", Uy = "≤", Hy = "≦", Gy = "⩽", Vy = "⪨", Zy = "⩽", jy = "⩿", Ky = "⪁", Wy = "⪃", Yy = "⋚︀", Jy = "⪓", Xy = "⪅", Qy = "⋖", eE = "⋚", nE = "⪋", tE = "⋚", rE = "≦", oE = "≶", sE = "≶", cE = "⪡", iE = "≲", aE = "⩽", lE = "≲", uE = "⥼", fE = "⌊", hE = "𝔏", pE = "𝔩", dE = "≶", gE = "⪑", _E = "⥢", mE = "↽", bE = "↼", vE = "⥪", kE = "▄", xE = "Љ", yE = "љ", EE = "⇇", AE = "≪", CE = "⋘", wE = "⌞", SE = "⇚", RE = "⥫", DE = "◺", TE = "Ŀ", ME = "ŀ", NE = "⎰", IE = "⎰", LE = "⪉", qE = "⪉", FE = "⪇", OE = "≨", BE = "⪇", PE = "≨", zE = "⋦", $E = "⟬", UE = "⇽", HE = "⟦", GE = "⟵", VE = "⟵", ZE = "⟸", jE = "⟷", KE = "⟷", WE = "⟺", YE = "⟼", JE = "⟶", XE = "⟶", QE = "⟹", eA = "↫", nA = "↬", tA = "⦅", rA = "𝕃", oA = "𝕝", sA = "⨭", cA = "⨴", iA = "∗", aA = "_", lA = "↙", uA = "↘", fA = "◊", hA = "◊", pA = "⧫", dA = "(", gA = "⦓", _A = "⇆", mA = "⌟", bA = "⇋", vA = "⥭", kA = "‎", xA = "⊿", yA = "‹", EA = "𝓁", AA = "ℒ", CA = "↰", wA = "↰", SA = "≲", RA = "⪍", DA = "⪏", TA = "[", MA = "‘", NA = "‚", IA = "Ł", LA = "ł", qA = "⪦", FA = "⩹", OA = "<", BA = "<", PA = "≪", zA = "⋖", $A = "⋋", UA = "⋉", HA = "⥶", GA = "⩻", VA = "◃", ZA = "⊴", jA = "◂", KA = "⦖", WA = "⥊", YA = "⥦", JA = "≨︀", XA = "≨︀", QA = "¯", eC = "♂", nC = "✠", tC = "✠", rC = "↦", oC = "↦", sC = "↧", cC = "↤", iC = "↥", aC = "▮", lC = "⨩", uC = "М", fC = "м", hC = "—", pC = "∺", dC = "∡", gC = " ", _C = "ℳ", mC = "𝔐", bC = "𝔪", vC = "℧", kC = "µ", xC = "*", yC = "⫰", EC = "∣", AC = "·", CC = "⊟", wC = "−", SC = "∸", RC = "⨪", DC = "∓", TC = "⫛", MC = "…", NC = "∓", IC = "⊧", LC = "𝕄", qC = "𝕞", FC = "∓", OC = "𝓂", BC = "ℳ", PC = "∾", zC = "Μ", $C = "μ", UC = "⊸", HC = "⊸", GC = "∇", VC = "Ń", ZC = "ń", jC = "∠⃒", KC = "≉", WC = "⩰̸", YC = "≋̸", JC = "ŉ", XC = "≉", QC = "♮", ew = "ℕ", nw = "♮", tw = " ", rw = "≎̸", ow = "≏̸", sw = "⩃", cw = "Ň", iw = "ň", aw = "Ņ", lw = "ņ", uw = "≇", fw = "⩭̸", hw = "⩂", pw = "Н", dw = "н", gw = "–", _w = "⤤", mw = "↗", bw = "⇗", vw = "↗", kw = "≠", xw = "≐̸", yw = "​", Ew = "​", Aw = "​", Cw = "​", ww = "≢", Sw = "⤨", Rw = "≂̸", Dw = "≫", Tw = "≪", Mw = `
`, Nw = "∄", Iw = "∄", Lw = "𝔑", qw = "𝔫", Fw = "≧̸", Ow = "≱", Bw = "≱", Pw = "≧̸", zw = "⩾̸", $w = "⩾̸", Uw = "⋙̸", Hw = "≵", Gw = "≫⃒", Vw = "≯", Zw = "≯", jw = "≫̸", Kw = "↮", Ww = "⇎", Yw = "⫲", Jw = "∋", Xw = "⋼", Qw = "⋺", eS = "∋", nS = "Њ", tS = "њ", rS = "↚", oS = "⇍", sS = "‥", cS = "≦̸", iS = "≰", aS = "↚", lS = "⇍", uS = "↮", fS = "⇎", hS = "≰", pS = "≦̸", dS = "⩽̸", gS = "⩽̸", _S = "≮", mS = "⋘̸", bS = "≴", vS = "≪⃒", kS = "≮", xS = "⋪", yS = "⋬", ES = "≪̸", AS = "∤", CS = "⁠", wS = " ", SS = "𝕟", RS = "ℕ", DS = "⫬", TS = "¬", MS = "≢", NS = "≭", IS = "∦", LS = "∉", qS = "≠", FS = "≂̸", OS = "∄", BS = "≯", PS = "≱", zS = "≧̸", $S = "≫̸", US = "≹", HS = "⩾̸", GS = "≵", VS = "≎̸", ZS = "≏̸", jS = "∉", KS = "⋵̸", WS = "⋹̸", YS = "∉", JS = "⋷", XS = "⋶", QS = "⧏̸", eR = "⋪", nR = "⋬", tR = "≮", rR = "≰", oR = "≸", sR = "≪̸", cR = "⩽̸", iR = "≴", aR = "⪢̸", lR = "⪡̸", uR = "∌", fR = "∌", hR = "⋾", pR = "⋽", dR = "⊀", gR = "⪯̸", _R = "⋠", mR = "∌", bR = "⧐̸", vR = "⋫", kR = "⋭", xR = "⊏̸", yR = "⋢", ER = "⊐̸", AR = "⋣", CR = "⊂⃒", wR = "⊈", SR = "⊁", RR = "⪰̸", DR = "⋡", TR = "≿̸", MR = "⊃⃒", NR = "⊉", IR = "≁", LR = "≄", qR = "≇", FR = "≉", OR = "∤", BR = "∦", PR = "∦", zR = "⫽⃥", $R = "∂̸", UR = "⨔", HR = "⊀", GR = "⋠", VR = "⊀", ZR = "⪯̸", jR = "⪯̸", KR = "⤳̸", WR = "↛", YR = "⇏", JR = "↝̸", XR = "↛", QR = "⇏", eD = "⋫", nD = "⋭", tD = "⊁", rD = "⋡", oD = "⪰̸", sD = "𝒩", cD = "𝓃", iD = "∤", aD = "∦", lD = "≁", uD = "≄", fD = "≄", hD = "∤", pD = "∦", dD = "⋢", gD = "⋣", _D = "⊄", mD = "⫅̸", bD = "⊈", vD = "⊂⃒", kD = "⊈", xD = "⫅̸", yD = "⊁", ED = "⪰̸", AD = "⊅", CD = "⫆̸", wD = "⊉", SD = "⊃⃒", RD = "⊉", DD = "⫆̸", TD = "≹", MD = "Ñ", ND = "ñ", ID = "≸", LD = "⋪", qD = "⋬", FD = "⋫", OD = "⋭", BD = "Ν", PD = "ν", zD = "#", $D = "№", UD = " ", HD = "≍⃒", GD = "⊬", VD = "⊭", ZD = "⊮", jD = "⊯", KD = "≥⃒", WD = ">⃒", YD = "⤄", JD = "⧞", XD = "⤂", QD = "≤⃒", eT = "<⃒", nT = "⊴⃒", tT = "⤃", rT = "⊵⃒", oT = "∼⃒", sT = "⤣", cT = "↖", iT = "⇖", aT = "↖", lT = "⤧", uT = "Ó", fT = "ó", hT = "⊛", pT = "Ô", dT = "ô", gT = "⊚", _T = "О", mT = "о", bT = "⊝", vT = "Ő", kT = "ő", xT = "⨸", yT = "⊙", ET = "⦼", AT = "Œ", CT = "œ", wT = "⦿", ST = "𝔒", RT = "𝔬", DT = "˛", TT = "Ò", MT = "ò", NT = "⧁", IT = "⦵", LT = "Ω", qT = "∮", FT = "↺", OT = "⦾", BT = "⦻", PT = "‾", zT = "⧀", $T = "Ō", UT = "ō", HT = "Ω", GT = "ω", VT = "Ο", ZT = "ο", jT = "⦶", KT = "⊖", WT = "𝕆", YT = "𝕠", JT = "⦷", XT = "“", QT = "‘", e2 = "⦹", n2 = "⊕", t2 = "↻", r2 = "⩔", o2 = "∨", s2 = "⩝", c2 = "ℴ", i2 = "ℴ", a2 = "ª", l2 = "º", u2 = "⊶", f2 = "⩖", h2 = "⩗", p2 = "⩛", d2 = "Ⓢ", g2 = "𝒪", _2 = "ℴ", m2 = "Ø", b2 = "ø", v2 = "⊘", k2 = "Õ", x2 = "õ", y2 = "⨶", E2 = "⨷", A2 = "⊗", C2 = "Ö", w2 = "ö", S2 = "⌽", R2 = "‾", D2 = "⏞", T2 = "⎴", M2 = "⏜", N2 = "¶", I2 = "∥", L2 = "∥", q2 = "⫳", F2 = "⫽", O2 = "∂", B2 = "∂", P2 = "П", z2 = "п", $2 = "%", U2 = ".", H2 = "‰", G2 = "⊥", V2 = "‱", Z2 = "𝔓", j2 = "𝔭", K2 = "Φ", W2 = "φ", Y2 = "ϕ", J2 = "ℳ", X2 = "☎", Q2 = "Π", eM = "π", nM = "⋔", tM = "ϖ", rM = "ℏ", oM = "ℎ", sM = "ℏ", cM = "⨣", iM = "⊞", aM = "⨢", lM = "+", uM = "∔", fM = "⨥", hM = "⩲", pM = "±", dM = "±", gM = "⨦", _M = "⨧", mM = "±", bM = "ℌ", vM = "⨕", kM = "𝕡", xM = "ℙ", yM = "£", EM = "⪷", AM = "⪻", CM = "≺", wM = "≼", SM = "⪷", RM = "≺", DM = "≼", TM = "≺", MM = "⪯", NM = "≼", IM = "≾", LM = "⪯", qM = "⪹", FM = "⪵", OM = "⋨", BM = "⪯", PM = "⪳", zM = "≾", $M = "′", UM = "″", HM = "ℙ", GM = "⪹", VM = "⪵", ZM = "⋨", jM = "∏", KM = "∏", WM = "⌮", YM = "⌒", JM = "⌓", XM = "∝", QM = "∝", eN = "∷", nN = "∝", tN = "≾", rN = "⊰", oN = "𝒫", sN = "𝓅", cN = "Ψ", iN = "ψ", aN = " ", lN = "𝔔", uN = "𝔮", fN = "⨌", hN = "𝕢", pN = "ℚ", dN = "⁗", gN = "𝒬", _N = "𝓆", mN = "ℍ", bN = "⨖", vN = "?", kN = "≟", xN = '"', yN = '"', EN = "⇛", AN = "∽̱", CN = "Ŕ", wN = "ŕ", SN = "√", RN = "⦳", DN = "⟩", TN = "⟫", MN = "⦒", NN = "⦥", IN = "⟩", LN = "»", qN = "⥵", FN = "⇥", ON = "⤠", BN = "⤳", PN = "→", zN = "↠", $N = "⇒", UN = "⤞", HN = "↪", GN = "↬", VN = "⥅", ZN = "⥴", jN = "⤖", KN = "↣", WN = "↝", YN = "⤚", JN = "⤜", XN = "∶", QN = "ℚ", eI = "⤍", nI = "⤏", tI = "⤐", rI = "❳", oI = "}", sI = "]", cI = "⦌", iI = "⦎", aI = "⦐", lI = "Ř", uI = "ř", fI = "Ŗ", hI = "ŗ", pI = "⌉", dI = "}", gI = "Р", _I = "р", mI = "⤷", bI = "⥩", vI = "”", kI = "”", xI = "↳", yI = "ℜ", EI = "ℛ", AI = "ℜ", CI = "ℝ", wI = "ℜ", SI = "▭", RI = "®", DI = "®", TI = "∋", MI = "⇋", NI = "⥯", II = "⥽", LI = "⌋", qI = "𝔯", FI = "ℜ", OI = "⥤", BI = "⇁", PI = "⇀", zI = "⥬", $I = "Ρ", UI = "ρ", HI = "ϱ", GI = "⟩", VI = "⇥", ZI = "→", jI = "→", KI = "⇒", WI = "⇄", YI = "↣", JI = "⌉", XI = "⟧", QI = "⥝", eL = "⥕", nL = "⇂", tL = "⌋", rL = "⇁", oL = "⇀", sL = "⇄", cL = "⇌", iL = "⇉", aL = "↝", lL = "↦", uL = "⊢", fL = "⥛", hL = "⋌", pL = "⧐", dL = "⊳", gL = "⊵", _L = "⥏", mL = "⥜", bL = "⥔", vL = "↾", kL = "⥓", xL = "⇀", yL = "˚", EL = "≓", AL = "⇄", CL = "⇌", wL = "‏", SL = "⎱", RL = "⎱", DL = "⫮", TL = "⟭", ML = "⇾", NL = "⟧", IL = "⦆", LL = "𝕣", qL = "ℝ", FL = "⨮", OL = "⨵", BL = "⥰", PL = ")", zL = "⦔", $L = "⨒", UL = "⇉", HL = "⇛", GL = "›", VL = "𝓇", ZL = "ℛ", jL = "↱", KL = "↱", WL = "]", YL = "’", JL = "’", XL = "⋌", QL = "⋊", eq = "▹", nq = "⊵", tq = "▸", rq = "⧎", oq = "⧴", sq = "⥨", cq = "℞", iq = "Ś", aq = "ś", lq = "‚", uq = "⪸", fq = "Š", hq = "š", pq = "⪼", dq = "≻", gq = "≽", _q = "⪰", mq = "⪴", bq = "Ş", vq = "ş", kq = "Ŝ", xq = "ŝ", yq = "⪺", Eq = "⪶", Aq = "⋩", Cq = "⨓", wq = "≿", Sq = "С", Rq = "с", Dq = "⊡", Tq = "⋅", Mq = "⩦", Nq = "⤥", Iq = "↘", Lq = "⇘", qq = "↘", Fq = "§", Oq = ";", Bq = "⤩", Pq = "∖", zq = "∖", $q = "✶", Uq = "𝔖", Hq = "𝔰", Gq = "⌢", Vq = "♯", Zq = "Щ", jq = "щ", Kq = "Ш", Wq = "ш", Yq = "↓", Jq = "←", Xq = "∣", Qq = "∥", eF = "→", nF = "↑", tF = "­", rF = "Σ", oF = "σ", sF = "ς", cF = "ς", iF = "∼", aF = "⩪", lF = "≃", uF = "≃", fF = "⪞", hF = "⪠", pF = "⪝", dF = "⪟", gF = "≆", _F = "⨤", mF = "⥲", bF = "←", vF = "∘", kF = "∖", xF = "⨳", yF = "⧤", EF = "∣", AF = "⌣", CF = "⪪", wF = "⪬", SF = "⪬︀", RF = "Ь", DF = "ь", TF = "⌿", MF = "⧄", NF = "/", IF = "𝕊", LF = "𝕤", qF = "♠", FF = "♠", OF = "∥", BF = "⊓", PF = "⊓︀", zF = "⊔", $F = "⊔︀", UF = "√", HF = "⊏", GF = "⊑", VF = "⊏", ZF = "⊑", jF = "⊐", KF = "⊒", WF = "⊐", YF = "⊒", JF = "□", XF = "□", QF = "⊓", eO = "⊏", nO = "⊑", tO = "⊐", rO = "⊒", oO = "⊔", sO = "▪", cO = "□", iO = "▪", aO = "→", lO = "𝒮", uO = "𝓈", fO = "∖", hO = "⌣", pO = "⋆", dO = "⋆", gO = "☆", _O = "★", mO = "ϵ", bO = "ϕ", vO = "¯", kO = "⊂", xO = "⋐", yO = "⪽", EO = "⫅", AO = "⊆", CO = "⫃", wO = "⫁", SO = "⫋", RO = "⊊", DO = "⪿", TO = "⥹", MO = "⊂", NO = "⋐", IO = "⊆", LO = "⫅", qO = "⊆", FO = "⊊", OO = "⫋", BO = "⫇", PO = "⫕", zO = "⫓", $O = "⪸", UO = "≻", HO = "≽", GO = "≻", VO = "⪰", ZO = "≽", jO = "≿", KO = "⪰", WO = "⪺", YO = "⪶", JO = "⋩", XO = "≿", QO = "∋", eB = "∑", nB = "∑", tB = "♪", rB = "¹", oB = "²", sB = "³", cB = "⊃", iB = "⋑", aB = "⪾", lB = "⫘", uB = "⫆", fB = "⊇", hB = "⫄", pB = "⊃", dB = "⊇", gB = "⟉", _B = "⫗", mB = "⥻", bB = "⫂", vB = "⫌", kB = "⊋", xB = "⫀", yB = "⊃", EB = "⋑", AB = "⊇", CB = "⫆", wB = "⊋", SB = "⫌", RB = "⫈", DB = "⫔", TB = "⫖", MB = "⤦", NB = "↙", IB = "⇙", LB = "↙", qB = "⤪", FB = "ß", OB = "	", BB = "⌖", PB = "Τ", zB = "τ", $B = "⎴", UB = "Ť", HB = "ť", GB = "Ţ", VB = "ţ", ZB = "Т", jB = "т", KB = "⃛", WB = "⌕", YB = "𝔗", JB = "𝔱", XB = "∴", QB = "∴", eP = "∴", nP = "Θ", tP = "θ", rP = "ϑ", oP = "ϑ", sP = "≈", cP = "∼", iP = "  ", aP = " ", lP = " ", uP = "≈", fP = "∼", hP = "Þ", pP = "þ", dP = "˜", gP = "∼", _P = "≃", mP = "≅", bP = "≈", vP = "⨱", kP = "⊠", xP = "×", yP = "⨰", EP = "∭", AP = "⤨", CP = "⌶", wP = "⫱", SP = "⊤", RP = "𝕋", DP = "𝕥", TP = "⫚", MP = "⤩", NP = "‴", IP = "™", LP = "™", qP = "▵", FP = "▿", OP = "◃", BP = "⊴", PP = "≜", zP = "▹", $P = "⊵", UP = "◬", HP = "≜", GP = "⨺", VP = "⃛", ZP = "⨹", jP = "⧍", KP = "⨻", WP = "⏢", YP = "𝒯", JP = "𝓉", XP = "Ц", QP = "ц", ez = "Ћ", nz = "ћ", tz = "Ŧ", rz = "ŧ", oz = "≬", sz = "↞", cz = "↠", iz = "Ú", az = "ú", lz = "↑", uz = "↟", fz = "⇑", hz = "⥉", pz = "Ў", dz = "ў", gz = "Ŭ", _z = "ŭ", mz = "Û", bz = "û", vz = "У", kz = "у", xz = "⇅", yz = "Ű", Ez = "ű", Az = "⥮", Cz = "⥾", wz = "𝔘", Sz = "𝔲", Rz = "Ù", Dz = "ù", Tz = "⥣", Mz = "↿", Nz = "↾", Iz = "▀", Lz = "⌜", qz = "⌜", Fz = "⌏", Oz = "◸", Bz = "Ū", Pz = "ū", zz = "¨", $z = "_", Uz = "⏟", Hz = "⎵", Gz = "⏝", Vz = "⋃", Zz = "⊎", jz = "Ų", Kz = "ų", Wz = "𝕌", Yz = "𝕦", Jz = "⤒", Xz = "↑", Qz = "↑", e$ = "⇑", n$ = "⇅", t$ = "↕", r$ = "↕", o$ = "⇕", s$ = "⥮", c$ = "↿", i$ = "↾", a$ = "⊎", l$ = "↖", u$ = "↗", f$ = "υ", h$ = "ϒ", p$ = "ϒ", d$ = "Υ", g$ = "υ", _$ = "↥", m$ = "⊥", b$ = "⇈", v$ = "⌝", k$ = "⌝", x$ = "⌎", y$ = "Ů", E$ = "ů", A$ = "◹", C$ = "𝒰", w$ = "𝓊", S$ = "⋰", R$ = "Ũ", D$ = "ũ", T$ = "▵", M$ = "▴", N$ = "⇈", I$ = "Ü", L$ = "ü", q$ = "⦧", F$ = "⦜", O$ = "ϵ", B$ = "ϰ", P$ = "∅", z$ = "ϕ", $$ = "ϖ", U$ = "∝", H$ = "↕", G$ = "⇕", V$ = "ϱ", Z$ = "ς", j$ = "⊊︀", K$ = "⫋︀", W$ = "⊋︀", Y$ = "⫌︀", J$ = "ϑ", X$ = "⊲", Q$ = "⊳", e3 = "⫨", n3 = "⫫", t3 = "⫩", r3 = "В", o3 = "в", s3 = "⊢", c3 = "⊨", i3 = "⊩", a3 = "⊫", l3 = "⫦", u3 = "⊻", f3 = "∨", h3 = "⋁", p3 = "≚", d3 = "⋮", g3 = "|", _3 = "‖", m3 = "|", b3 = "‖", v3 = "∣", k3 = "|", x3 = "❘", y3 = "≀", E3 = " ", A3 = "𝔙", C3 = "𝔳", w3 = "⊲", S3 = "⊂⃒", R3 = "⊃⃒", D3 = "𝕍", T3 = "𝕧", M3 = "∝", N3 = "⊳", I3 = "𝒱", L3 = "𝓋", q3 = "⫋︀", F3 = "⊊︀", O3 = "⫌︀", B3 = "⊋︀", P3 = "⊪", z3 = "⦚", $3 = "Ŵ", U3 = "ŵ", H3 = "⩟", G3 = "∧", V3 = "⋀", Z3 = "≙", j3 = "℘", K3 = "𝔚", W3 = "𝔴", Y3 = "𝕎", J3 = "𝕨", X3 = "℘", Q3 = "≀", eU = "≀", nU = "𝒲", tU = "𝓌", rU = "⋂", oU = "◯", sU = "⋃", cU = "▽", iU = "𝔛", aU = "𝔵", lU = "⟷", uU = "⟺", fU = "Ξ", hU = "ξ", pU = "⟵", dU = "⟸", gU = "⟼", _U = "⋻", mU = "⨀", bU = "𝕏", vU = "𝕩", kU = "⨁", xU = "⨂", yU = "⟶", EU = "⟹", AU = "𝒳", CU = "𝓍", wU = "⨆", SU = "⨄", RU = "△", DU = "⋁", TU = "⋀", MU = "Ý", NU = "ý", IU = "Я", LU = "я", qU = "Ŷ", FU = "ŷ", OU = "Ы", BU = "ы", PU = "¥", zU = "𝔜", $U = "𝔶", UU = "Ї", HU = "ї", GU = "𝕐", VU = "𝕪", ZU = "𝒴", jU = "𝓎", KU = "Ю", WU = "ю", YU = "ÿ", JU = "Ÿ", XU = "Ź", QU = "ź", e5 = "Ž", n5 = "ž", t5 = "З", r5 = "з", o5 = "Ż", s5 = "ż", c5 = "ℨ", i5 = "​", a5 = "Ζ", l5 = "ζ", u5 = "𝔷", f5 = "ℨ", h5 = "Ж", p5 = "ж", d5 = "⇝", g5 = "𝕫", _5 = "ℤ", m5 = "𝒵", b5 = "𝓏", v5 = "‍", k5 = "‌", x5 = {
  Aacute: ra,
  aacute: oa,
  Abreve: sa,
  abreve: ca,
  ac: ia,
  acd: aa,
  acE: la,
  Acirc: ua,
  acirc: fa,
  acute: ha,
  Acy: pa,
  acy: da,
  AElig: ga,
  aelig: _a,
  af: ma,
  Afr: ba,
  afr: va,
  Agrave: ka,
  agrave: xa,
  alefsym: ya,
  aleph: Ea,
  Alpha: Aa,
  alpha: Ca,
  Amacr: wa,
  amacr: Sa,
  amalg: Ra,
  amp: Da,
  AMP: Ta,
  andand: Ma,
  And: Na,
  and: Ia,
  andd: La,
  andslope: qa,
  andv: Fa,
  ang: Oa,
  ange: Ba,
  angle: Pa,
  angmsdaa: za,
  angmsdab: $a,
  angmsdac: Ua,
  angmsdad: Ha,
  angmsdae: Ga,
  angmsdaf: Va,
  angmsdag: Za,
  angmsdah: ja,
  angmsd: Ka,
  angrt: Wa,
  angrtvb: Ya,
  angrtvbd: Ja,
  angsph: Xa,
  angst: Qa,
  angzarr: el,
  Aogon: nl,
  aogon: tl,
  Aopf: rl,
  aopf: ol,
  apacir: sl,
  ap: cl,
  apE: il,
  ape: al,
  apid: ll,
  apos: ul,
  ApplyFunction: fl,
  approx: hl,
  approxeq: pl,
  Aring: dl,
  aring: gl,
  Ascr: _l,
  ascr: ml,
  Assign: bl,
  ast: vl,
  asymp: kl,
  asympeq: xl,
  Atilde: yl,
  atilde: El,
  Auml: Al,
  auml: Cl,
  awconint: wl,
  awint: Sl,
  backcong: Rl,
  backepsilon: Dl,
  backprime: Tl,
  backsim: Ml,
  backsimeq: Nl,
  Backslash: Il,
  Barv: Ll,
  barvee: ql,
  barwed: Fl,
  Barwed: Ol,
  barwedge: Bl,
  bbrk: Pl,
  bbrktbrk: zl,
  bcong: $l,
  Bcy: Ul,
  bcy: Hl,
  bdquo: Gl,
  becaus: Vl,
  because: Zl,
  Because: jl,
  bemptyv: Kl,
  bepsi: Wl,
  bernou: Yl,
  Bernoullis: Jl,
  Beta: Xl,
  beta: Ql,
  beth: eu,
  between: nu,
  Bfr: tu,
  bfr: ru,
  bigcap: ou,
  bigcirc: su,
  bigcup: cu,
  bigodot: iu,
  bigoplus: au,
  bigotimes: lu,
  bigsqcup: uu,
  bigstar: fu,
  bigtriangledown: hu,
  bigtriangleup: pu,
  biguplus: du,
  bigvee: gu,
  bigwedge: _u,
  bkarow: mu,
  blacklozenge: bu,
  blacksquare: vu,
  blacktriangle: ku,
  blacktriangledown: xu,
  blacktriangleleft: yu,
  blacktriangleright: Eu,
  blank: Au,
  blk12: Cu,
  blk14: wu,
  blk34: Su,
  block: Ru,
  bne: Du,
  bnequiv: Tu,
  bNot: Mu,
  bnot: Nu,
  Bopf: Iu,
  bopf: Lu,
  bot: qu,
  bottom: Fu,
  bowtie: Ou,
  boxbox: Bu,
  boxdl: Pu,
  boxdL: zu,
  boxDl: $u,
  boxDL: Uu,
  boxdr: Hu,
  boxdR: Gu,
  boxDr: Vu,
  boxDR: Zu,
  boxh: ju,
  boxH: Ku,
  boxhd: Wu,
  boxHd: Yu,
  boxhD: Ju,
  boxHD: Xu,
  boxhu: Qu,
  boxHu: ef,
  boxhU: nf,
  boxHU: tf,
  boxminus: rf,
  boxplus: of,
  boxtimes: sf,
  boxul: cf,
  boxuL: af,
  boxUl: lf,
  boxUL: uf,
  boxur: ff,
  boxuR: hf,
  boxUr: pf,
  boxUR: df,
  boxv: gf,
  boxV: _f,
  boxvh: mf,
  boxvH: bf,
  boxVh: vf,
  boxVH: kf,
  boxvl: xf,
  boxvL: yf,
  boxVl: Ef,
  boxVL: Af,
  boxvr: Cf,
  boxvR: wf,
  boxVr: Sf,
  boxVR: Rf,
  bprime: Df,
  breve: Tf,
  Breve: Mf,
  brvbar: Nf,
  bscr: If,
  Bscr: Lf,
  bsemi: qf,
  bsim: Ff,
  bsime: Of,
  bsolb: Bf,
  bsol: Pf,
  bsolhsub: zf,
  bull: $f,
  bullet: Uf,
  bump: Hf,
  bumpE: Gf,
  bumpe: Vf,
  Bumpeq: Zf,
  bumpeq: jf,
  Cacute: Kf,
  cacute: Wf,
  capand: Yf,
  capbrcup: Jf,
  capcap: Xf,
  cap: Qf,
  Cap: eh,
  capcup: nh,
  capdot: th,
  CapitalDifferentialD: rh,
  caps: oh,
  caret: sh,
  caron: ch,
  Cayleys: ih,
  ccaps: ah,
  Ccaron: lh,
  ccaron: uh,
  Ccedil: fh,
  ccedil: hh,
  Ccirc: ph,
  ccirc: dh,
  Cconint: gh,
  ccups: _h,
  ccupssm: mh,
  Cdot: bh,
  cdot: vh,
  cedil: kh,
  Cedilla: xh,
  cemptyv: yh,
  cent: Eh,
  centerdot: Ah,
  CenterDot: Ch,
  cfr: wh,
  Cfr: Sh,
  CHcy: Rh,
  chcy: Dh,
  check: Th,
  checkmark: Mh,
  Chi: Nh,
  chi: Ih,
  circ: Lh,
  circeq: qh,
  circlearrowleft: Fh,
  circlearrowright: Oh,
  circledast: Bh,
  circledcirc: Ph,
  circleddash: zh,
  CircleDot: $h,
  circledR: Uh,
  circledS: Hh,
  CircleMinus: Gh,
  CirclePlus: Vh,
  CircleTimes: Zh,
  cir: jh,
  cirE: Kh,
  cire: Wh,
  cirfnint: Yh,
  cirmid: Jh,
  cirscir: Xh,
  ClockwiseContourIntegral: Qh,
  CloseCurlyDoubleQuote: ep,
  CloseCurlyQuote: np,
  clubs: tp,
  clubsuit: rp,
  colon: op,
  Colon: sp,
  Colone: cp,
  colone: ip,
  coloneq: ap,
  comma: lp,
  commat: up,
  comp: fp,
  compfn: hp,
  complement: pp,
  complexes: dp,
  cong: gp,
  congdot: _p,
  Congruent: mp,
  conint: bp,
  Conint: vp,
  ContourIntegral: kp,
  copf: xp,
  Copf: yp,
  coprod: Ep,
  Coproduct: Ap,
  copy: Cp,
  COPY: wp,
  copysr: Sp,
  CounterClockwiseContourIntegral: Rp,
  crarr: Dp,
  cross: Tp,
  Cross: Mp,
  Cscr: Np,
  cscr: Ip,
  csub: Lp,
  csube: qp,
  csup: Fp,
  csupe: Op,
  ctdot: Bp,
  cudarrl: Pp,
  cudarrr: zp,
  cuepr: $p,
  cuesc: Up,
  cularr: Hp,
  cularrp: Gp,
  cupbrcap: Vp,
  cupcap: Zp,
  CupCap: jp,
  cup: Kp,
  Cup: Wp,
  cupcup: Yp,
  cupdot: Jp,
  cupor: Xp,
  cups: Qp,
  curarr: ed,
  curarrm: nd,
  curlyeqprec: td,
  curlyeqsucc: rd,
  curlyvee: od,
  curlywedge: sd,
  curren: cd,
  curvearrowleft: id,
  curvearrowright: ad,
  cuvee: ld,
  cuwed: ud,
  cwconint: fd,
  cwint: hd,
  cylcty: pd,
  dagger: dd,
  Dagger: gd,
  daleth: _d,
  darr: md,
  Darr: bd,
  dArr: vd,
  dash: kd,
  Dashv: xd,
  dashv: yd,
  dbkarow: Ed,
  dblac: Ad,
  Dcaron: Cd,
  dcaron: wd,
  Dcy: Sd,
  dcy: Rd,
  ddagger: Dd,
  ddarr: Td,
  DD: Md,
  dd: Nd,
  DDotrahd: Id,
  ddotseq: Ld,
  deg: qd,
  Del: Fd,
  Delta: Od,
  delta: Bd,
  demptyv: Pd,
  dfisht: zd,
  Dfr: $d,
  dfr: Ud,
  dHar: Hd,
  dharl: Gd,
  dharr: Vd,
  DiacriticalAcute: Zd,
  DiacriticalDot: jd,
  DiacriticalDoubleAcute: Kd,
  DiacriticalGrave: Wd,
  DiacriticalTilde: Yd,
  diam: Jd,
  diamond: Xd,
  Diamond: Qd,
  diamondsuit: eg,
  diams: ng,
  die: tg,
  DifferentialD: rg,
  digamma: og,
  disin: sg,
  div: cg,
  divide: ig,
  divideontimes: ag,
  divonx: lg,
  DJcy: ug,
  djcy: fg,
  dlcorn: hg,
  dlcrop: pg,
  dollar: dg,
  Dopf: gg,
  dopf: _g,
  Dot: mg,
  dot: bg,
  DotDot: vg,
  doteq: kg,
  doteqdot: xg,
  DotEqual: yg,
  dotminus: Eg,
  dotplus: Ag,
  dotsquare: Cg,
  doublebarwedge: wg,
  DoubleContourIntegral: Sg,
  DoubleDot: Rg,
  DoubleDownArrow: Dg,
  DoubleLeftArrow: Tg,
  DoubleLeftRightArrow: Mg,
  DoubleLeftTee: Ng,
  DoubleLongLeftArrow: Ig,
  DoubleLongLeftRightArrow: Lg,
  DoubleLongRightArrow: qg,
  DoubleRightArrow: Fg,
  DoubleRightTee: Og,
  DoubleUpArrow: Bg,
  DoubleUpDownArrow: Pg,
  DoubleVerticalBar: zg,
  DownArrowBar: $g,
  downarrow: Ug,
  DownArrow: Hg,
  Downarrow: Gg,
  DownArrowUpArrow: Vg,
  DownBreve: Zg,
  downdownarrows: jg,
  downharpoonleft: Kg,
  downharpoonright: Wg,
  DownLeftRightVector: Yg,
  DownLeftTeeVector: Jg,
  DownLeftVectorBar: Xg,
  DownLeftVector: Qg,
  DownRightTeeVector: e_,
  DownRightVectorBar: n_,
  DownRightVector: t_,
  DownTeeArrow: r_,
  DownTee: o_,
  drbkarow: s_,
  drcorn: c_,
  drcrop: i_,
  Dscr: a_,
  dscr: l_,
  DScy: u_,
  dscy: f_,
  dsol: h_,
  Dstrok: p_,
  dstrok: d_,
  dtdot: g_,
  dtri: __,
  dtrif: m_,
  duarr: b_,
  duhar: v_,
  dwangle: k_,
  DZcy: x_,
  dzcy: y_,
  dzigrarr: E_,
  Eacute: A_,
  eacute: C_,
  easter: w_,
  Ecaron: S_,
  ecaron: R_,
  Ecirc: D_,
  ecirc: T_,
  ecir: M_,
  ecolon: N_,
  Ecy: I_,
  ecy: L_,
  eDDot: q_,
  Edot: F_,
  edot: O_,
  eDot: B_,
  ee: P_,
  efDot: z_,
  Efr: $_,
  efr: U_,
  eg: H_,
  Egrave: G_,
  egrave: V_,
  egs: Z_,
  egsdot: j_,
  el: K_,
  Element: W_,
  elinters: Y_,
  ell: J_,
  els: X_,
  elsdot: Q_,
  Emacr: em,
  emacr: nm,
  empty: tm,
  emptyset: rm,
  EmptySmallSquare: om,
  emptyv: sm,
  EmptyVerySmallSquare: cm,
  emsp13: im,
  emsp14: am,
  emsp: lm,
  ENG: um,
  eng: fm,
  ensp: hm,
  Eogon: pm,
  eogon: dm,
  Eopf: gm,
  eopf: _m,
  epar: mm,
  eparsl: bm,
  eplus: vm,
  epsi: km,
  Epsilon: xm,
  epsilon: ym,
  epsiv: Em,
  eqcirc: Am,
  eqcolon: Cm,
  eqsim: wm,
  eqslantgtr: Sm,
  eqslantless: Rm,
  Equal: Dm,
  equals: Tm,
  EqualTilde: Mm,
  equest: Nm,
  Equilibrium: Im,
  equiv: Lm,
  equivDD: qm,
  eqvparsl: Fm,
  erarr: Om,
  erDot: Bm,
  escr: Pm,
  Escr: zm,
  esdot: $m,
  Esim: Um,
  esim: Hm,
  Eta: Gm,
  eta: Vm,
  ETH: Zm,
  eth: jm,
  Euml: Km,
  euml: Wm,
  euro: Ym,
  excl: Jm,
  exist: Xm,
  Exists: Qm,
  expectation: e0,
  exponentiale: n0,
  ExponentialE: t0,
  fallingdotseq: r0,
  Fcy: o0,
  fcy: s0,
  female: c0,
  ffilig: i0,
  fflig: a0,
  ffllig: l0,
  Ffr: u0,
  ffr: f0,
  filig: h0,
  FilledSmallSquare: p0,
  FilledVerySmallSquare: d0,
  fjlig: g0,
  flat: _0,
  fllig: m0,
  fltns: b0,
  fnof: v0,
  Fopf: k0,
  fopf: x0,
  forall: y0,
  ForAll: E0,
  fork: A0,
  forkv: C0,
  Fouriertrf: w0,
  fpartint: S0,
  frac12: R0,
  frac13: D0,
  frac14: T0,
  frac15: M0,
  frac16: N0,
  frac18: I0,
  frac23: L0,
  frac25: q0,
  frac34: F0,
  frac35: O0,
  frac38: B0,
  frac45: P0,
  frac56: z0,
  frac58: $0,
  frac78: U0,
  frasl: H0,
  frown: G0,
  fscr: V0,
  Fscr: Z0,
  gacute: j0,
  Gamma: K0,
  gamma: W0,
  Gammad: Y0,
  gammad: J0,
  gap: X0,
  Gbreve: Q0,
  gbreve: eb,
  Gcedil: nb,
  Gcirc: tb,
  gcirc: rb,
  Gcy: ob,
  gcy: sb,
  Gdot: cb,
  gdot: ib,
  ge: ab,
  gE: lb,
  gEl: ub,
  gel: fb,
  geq: hb,
  geqq: pb,
  geqslant: db,
  gescc: gb,
  ges: _b,
  gesdot: mb,
  gesdoto: bb,
  gesdotol: vb,
  gesl: kb,
  gesles: xb,
  Gfr: yb,
  gfr: Eb,
  gg: Ab,
  Gg: Cb,
  ggg: wb,
  gimel: Sb,
  GJcy: Rb,
  gjcy: Db,
  gla: Tb,
  gl: Mb,
  glE: Nb,
  glj: Ib,
  gnap: Lb,
  gnapprox: qb,
  gne: Fb,
  gnE: Ob,
  gneq: Bb,
  gneqq: Pb,
  gnsim: zb,
  Gopf: $b,
  gopf: Ub,
  grave: Hb,
  GreaterEqual: Gb,
  GreaterEqualLess: Vb,
  GreaterFullEqual: Zb,
  GreaterGreater: jb,
  GreaterLess: Kb,
  GreaterSlantEqual: Wb,
  GreaterTilde: Yb,
  Gscr: Jb,
  gscr: Xb,
  gsim: Qb,
  gsime: ev,
  gsiml: nv,
  gtcc: tv,
  gtcir: rv,
  gt: ov,
  GT: sv,
  Gt: cv,
  gtdot: iv,
  gtlPar: av,
  gtquest: lv,
  gtrapprox: uv,
  gtrarr: fv,
  gtrdot: hv,
  gtreqless: pv,
  gtreqqless: dv,
  gtrless: gv,
  gtrsim: _v,
  gvertneqq: mv,
  gvnE: bv,
  Hacek: vv,
  hairsp: kv,
  half: xv,
  hamilt: yv,
  HARDcy: Ev,
  hardcy: Av,
  harrcir: Cv,
  harr: wv,
  hArr: Sv,
  harrw: Rv,
  Hat: Dv,
  hbar: Tv,
  Hcirc: Mv,
  hcirc: Nv,
  hearts: Iv,
  heartsuit: Lv,
  hellip: qv,
  hercon: Fv,
  hfr: Ov,
  Hfr: Bv,
  HilbertSpace: Pv,
  hksearow: zv,
  hkswarow: $v,
  hoarr: Uv,
  homtht: Hv,
  hookleftarrow: Gv,
  hookrightarrow: Vv,
  hopf: Zv,
  Hopf: jv,
  horbar: Kv,
  HorizontalLine: Wv,
  hscr: Yv,
  Hscr: Jv,
  hslash: Xv,
  Hstrok: Qv,
  hstrok: ek,
  HumpDownHump: nk,
  HumpEqual: tk,
  hybull: rk,
  hyphen: ok,
  Iacute: sk,
  iacute: ck,
  ic: ik,
  Icirc: ak,
  icirc: lk,
  Icy: uk,
  icy: fk,
  Idot: hk,
  IEcy: pk,
  iecy: dk,
  iexcl: gk,
  iff: _k,
  ifr: mk,
  Ifr: bk,
  Igrave: vk,
  igrave: kk,
  ii: xk,
  iiiint: yk,
  iiint: Ek,
  iinfin: Ak,
  iiota: Ck,
  IJlig: wk,
  ijlig: Sk,
  Imacr: Rk,
  imacr: Dk,
  image: Tk,
  ImaginaryI: Mk,
  imagline: Nk,
  imagpart: Ik,
  imath: Lk,
  Im: qk,
  imof: Fk,
  imped: Ok,
  Implies: Bk,
  incare: Pk,
  in: "∈",
  infin: zk,
  infintie: $k,
  inodot: Uk,
  intcal: Hk,
  int: Gk,
  Int: Vk,
  integers: Zk,
  Integral: jk,
  intercal: Kk,
  Intersection: Wk,
  intlarhk: Yk,
  intprod: Jk,
  InvisibleComma: Xk,
  InvisibleTimes: Qk,
  IOcy: ex,
  iocy: nx,
  Iogon: tx,
  iogon: rx,
  Iopf: ox,
  iopf: sx,
  Iota: cx,
  iota: ix,
  iprod: ax,
  iquest: lx,
  iscr: ux,
  Iscr: fx,
  isin: hx,
  isindot: px,
  isinE: dx,
  isins: gx,
  isinsv: _x,
  isinv: mx,
  it: bx,
  Itilde: vx,
  itilde: kx,
  Iukcy: xx,
  iukcy: yx,
  Iuml: Ex,
  iuml: Ax,
  Jcirc: Cx,
  jcirc: wx,
  Jcy: Sx,
  jcy: Rx,
  Jfr: Dx,
  jfr: Tx,
  jmath: Mx,
  Jopf: Nx,
  jopf: Ix,
  Jscr: Lx,
  jscr: qx,
  Jsercy: Fx,
  jsercy: Ox,
  Jukcy: Bx,
  jukcy: Px,
  Kappa: zx,
  kappa: $x,
  kappav: Ux,
  Kcedil: Hx,
  kcedil: Gx,
  Kcy: Vx,
  kcy: Zx,
  Kfr: jx,
  kfr: Kx,
  kgreen: Wx,
  KHcy: Yx,
  khcy: Jx,
  KJcy: Xx,
  kjcy: Qx,
  Kopf: e1,
  kopf: n1,
  Kscr: t1,
  kscr: r1,
  lAarr: o1,
  Lacute: s1,
  lacute: c1,
  laemptyv: i1,
  lagran: a1,
  Lambda: l1,
  lambda: u1,
  lang: f1,
  Lang: h1,
  langd: p1,
  langle: d1,
  lap: g1,
  Laplacetrf: _1,
  laquo: m1,
  larrb: b1,
  larrbfs: v1,
  larr: k1,
  Larr: x1,
  lArr: y1,
  larrfs: E1,
  larrhk: A1,
  larrlp: C1,
  larrpl: w1,
  larrsim: S1,
  larrtl: R1,
  latail: D1,
  lAtail: T1,
  lat: M1,
  late: N1,
  lates: I1,
  lbarr: L1,
  lBarr: q1,
  lbbrk: F1,
  lbrace: O1,
  lbrack: B1,
  lbrke: P1,
  lbrksld: z1,
  lbrkslu: $1,
  Lcaron: U1,
  lcaron: H1,
  Lcedil: G1,
  lcedil: V1,
  lceil: Z1,
  lcub: j1,
  Lcy: K1,
  lcy: W1,
  ldca: Y1,
  ldquo: J1,
  ldquor: X1,
  ldrdhar: Q1,
  ldrushar: ey,
  ldsh: ny,
  le: ty,
  lE: ry,
  LeftAngleBracket: oy,
  LeftArrowBar: sy,
  leftarrow: cy,
  LeftArrow: iy,
  Leftarrow: ay,
  LeftArrowRightArrow: ly,
  leftarrowtail: uy,
  LeftCeiling: fy,
  LeftDoubleBracket: hy,
  LeftDownTeeVector: py,
  LeftDownVectorBar: dy,
  LeftDownVector: gy,
  LeftFloor: _y,
  leftharpoondown: my,
  leftharpoonup: by,
  leftleftarrows: vy,
  leftrightarrow: ky,
  LeftRightArrow: xy,
  Leftrightarrow: yy,
  leftrightarrows: Ey,
  leftrightharpoons: Ay,
  leftrightsquigarrow: Cy,
  LeftRightVector: wy,
  LeftTeeArrow: Sy,
  LeftTee: Ry,
  LeftTeeVector: Dy,
  leftthreetimes: Ty,
  LeftTriangleBar: My,
  LeftTriangle: Ny,
  LeftTriangleEqual: Iy,
  LeftUpDownVector: Ly,
  LeftUpTeeVector: qy,
  LeftUpVectorBar: Fy,
  LeftUpVector: Oy,
  LeftVectorBar: By,
  LeftVector: Py,
  lEg: zy,
  leg: $y,
  leq: Uy,
  leqq: Hy,
  leqslant: Gy,
  lescc: Vy,
  les: Zy,
  lesdot: jy,
  lesdoto: Ky,
  lesdotor: Wy,
  lesg: Yy,
  lesges: Jy,
  lessapprox: Xy,
  lessdot: Qy,
  lesseqgtr: eE,
  lesseqqgtr: nE,
  LessEqualGreater: tE,
  LessFullEqual: rE,
  LessGreater: oE,
  lessgtr: sE,
  LessLess: cE,
  lesssim: iE,
  LessSlantEqual: aE,
  LessTilde: lE,
  lfisht: uE,
  lfloor: fE,
  Lfr: hE,
  lfr: pE,
  lg: dE,
  lgE: gE,
  lHar: _E,
  lhard: mE,
  lharu: bE,
  lharul: vE,
  lhblk: kE,
  LJcy: xE,
  ljcy: yE,
  llarr: EE,
  ll: AE,
  Ll: CE,
  llcorner: wE,
  Lleftarrow: SE,
  llhard: RE,
  lltri: DE,
  Lmidot: TE,
  lmidot: ME,
  lmoustache: NE,
  lmoust: IE,
  lnap: LE,
  lnapprox: qE,
  lne: FE,
  lnE: OE,
  lneq: BE,
  lneqq: PE,
  lnsim: zE,
  loang: $E,
  loarr: UE,
  lobrk: HE,
  longleftarrow: GE,
  LongLeftArrow: VE,
  Longleftarrow: ZE,
  longleftrightarrow: jE,
  LongLeftRightArrow: KE,
  Longleftrightarrow: WE,
  longmapsto: YE,
  longrightarrow: JE,
  LongRightArrow: XE,
  Longrightarrow: QE,
  looparrowleft: eA,
  looparrowright: nA,
  lopar: tA,
  Lopf: rA,
  lopf: oA,
  loplus: sA,
  lotimes: cA,
  lowast: iA,
  lowbar: aA,
  LowerLeftArrow: lA,
  LowerRightArrow: uA,
  loz: fA,
  lozenge: hA,
  lozf: pA,
  lpar: dA,
  lparlt: gA,
  lrarr: _A,
  lrcorner: mA,
  lrhar: bA,
  lrhard: vA,
  lrm: kA,
  lrtri: xA,
  lsaquo: yA,
  lscr: EA,
  Lscr: AA,
  lsh: CA,
  Lsh: wA,
  lsim: SA,
  lsime: RA,
  lsimg: DA,
  lsqb: TA,
  lsquo: MA,
  lsquor: NA,
  Lstrok: IA,
  lstrok: LA,
  ltcc: qA,
  ltcir: FA,
  lt: OA,
  LT: BA,
  Lt: PA,
  ltdot: zA,
  lthree: $A,
  ltimes: UA,
  ltlarr: HA,
  ltquest: GA,
  ltri: VA,
  ltrie: ZA,
  ltrif: jA,
  ltrPar: KA,
  lurdshar: WA,
  luruhar: YA,
  lvertneqq: JA,
  lvnE: XA,
  macr: QA,
  male: eC,
  malt: nC,
  maltese: tC,
  Map: "⤅",
  map: rC,
  mapsto: oC,
  mapstodown: sC,
  mapstoleft: cC,
  mapstoup: iC,
  marker: aC,
  mcomma: lC,
  Mcy: uC,
  mcy: fC,
  mdash: hC,
  mDDot: pC,
  measuredangle: dC,
  MediumSpace: gC,
  Mellintrf: _C,
  Mfr: mC,
  mfr: bC,
  mho: vC,
  micro: kC,
  midast: xC,
  midcir: yC,
  mid: EC,
  middot: AC,
  minusb: CC,
  minus: wC,
  minusd: SC,
  minusdu: RC,
  MinusPlus: DC,
  mlcp: TC,
  mldr: MC,
  mnplus: NC,
  models: IC,
  Mopf: LC,
  mopf: qC,
  mp: FC,
  mscr: OC,
  Mscr: BC,
  mstpos: PC,
  Mu: zC,
  mu: $C,
  multimap: UC,
  mumap: HC,
  nabla: GC,
  Nacute: VC,
  nacute: ZC,
  nang: jC,
  nap: KC,
  napE: WC,
  napid: YC,
  napos: JC,
  napprox: XC,
  natural: QC,
  naturals: ew,
  natur: nw,
  nbsp: tw,
  nbump: rw,
  nbumpe: ow,
  ncap: sw,
  Ncaron: cw,
  ncaron: iw,
  Ncedil: aw,
  ncedil: lw,
  ncong: uw,
  ncongdot: fw,
  ncup: hw,
  Ncy: pw,
  ncy: dw,
  ndash: gw,
  nearhk: _w,
  nearr: mw,
  neArr: bw,
  nearrow: vw,
  ne: kw,
  nedot: xw,
  NegativeMediumSpace: yw,
  NegativeThickSpace: Ew,
  NegativeThinSpace: Aw,
  NegativeVeryThinSpace: Cw,
  nequiv: ww,
  nesear: Sw,
  nesim: Rw,
  NestedGreaterGreater: Dw,
  NestedLessLess: Tw,
  NewLine: Mw,
  nexist: Nw,
  nexists: Iw,
  Nfr: Lw,
  nfr: qw,
  ngE: Fw,
  nge: Ow,
  ngeq: Bw,
  ngeqq: Pw,
  ngeqslant: zw,
  nges: $w,
  nGg: Uw,
  ngsim: Hw,
  nGt: Gw,
  ngt: Vw,
  ngtr: Zw,
  nGtv: jw,
  nharr: Kw,
  nhArr: Ww,
  nhpar: Yw,
  ni: Jw,
  nis: Xw,
  nisd: Qw,
  niv: eS,
  NJcy: nS,
  njcy: tS,
  nlarr: rS,
  nlArr: oS,
  nldr: sS,
  nlE: cS,
  nle: iS,
  nleftarrow: aS,
  nLeftarrow: lS,
  nleftrightarrow: uS,
  nLeftrightarrow: fS,
  nleq: hS,
  nleqq: pS,
  nleqslant: dS,
  nles: gS,
  nless: _S,
  nLl: mS,
  nlsim: bS,
  nLt: vS,
  nlt: kS,
  nltri: xS,
  nltrie: yS,
  nLtv: ES,
  nmid: AS,
  NoBreak: CS,
  NonBreakingSpace: wS,
  nopf: SS,
  Nopf: RS,
  Not: DS,
  not: TS,
  NotCongruent: MS,
  NotCupCap: NS,
  NotDoubleVerticalBar: IS,
  NotElement: LS,
  NotEqual: qS,
  NotEqualTilde: FS,
  NotExists: OS,
  NotGreater: BS,
  NotGreaterEqual: PS,
  NotGreaterFullEqual: zS,
  NotGreaterGreater: $S,
  NotGreaterLess: US,
  NotGreaterSlantEqual: HS,
  NotGreaterTilde: GS,
  NotHumpDownHump: VS,
  NotHumpEqual: ZS,
  notin: jS,
  notindot: KS,
  notinE: WS,
  notinva: YS,
  notinvb: JS,
  notinvc: XS,
  NotLeftTriangleBar: QS,
  NotLeftTriangle: eR,
  NotLeftTriangleEqual: nR,
  NotLess: tR,
  NotLessEqual: rR,
  NotLessGreater: oR,
  NotLessLess: sR,
  NotLessSlantEqual: cR,
  NotLessTilde: iR,
  NotNestedGreaterGreater: aR,
  NotNestedLessLess: lR,
  notni: uR,
  notniva: fR,
  notnivb: hR,
  notnivc: pR,
  NotPrecedes: dR,
  NotPrecedesEqual: gR,
  NotPrecedesSlantEqual: _R,
  NotReverseElement: mR,
  NotRightTriangleBar: bR,
  NotRightTriangle: vR,
  NotRightTriangleEqual: kR,
  NotSquareSubset: xR,
  NotSquareSubsetEqual: yR,
  NotSquareSuperset: ER,
  NotSquareSupersetEqual: AR,
  NotSubset: CR,
  NotSubsetEqual: wR,
  NotSucceeds: SR,
  NotSucceedsEqual: RR,
  NotSucceedsSlantEqual: DR,
  NotSucceedsTilde: TR,
  NotSuperset: MR,
  NotSupersetEqual: NR,
  NotTilde: IR,
  NotTildeEqual: LR,
  NotTildeFullEqual: qR,
  NotTildeTilde: FR,
  NotVerticalBar: OR,
  nparallel: BR,
  npar: PR,
  nparsl: zR,
  npart: $R,
  npolint: UR,
  npr: HR,
  nprcue: GR,
  nprec: VR,
  npreceq: ZR,
  npre: jR,
  nrarrc: KR,
  nrarr: WR,
  nrArr: YR,
  nrarrw: JR,
  nrightarrow: XR,
  nRightarrow: QR,
  nrtri: eD,
  nrtrie: nD,
  nsc: tD,
  nsccue: rD,
  nsce: oD,
  Nscr: sD,
  nscr: cD,
  nshortmid: iD,
  nshortparallel: aD,
  nsim: lD,
  nsime: uD,
  nsimeq: fD,
  nsmid: hD,
  nspar: pD,
  nsqsube: dD,
  nsqsupe: gD,
  nsub: _D,
  nsubE: mD,
  nsube: bD,
  nsubset: vD,
  nsubseteq: kD,
  nsubseteqq: xD,
  nsucc: yD,
  nsucceq: ED,
  nsup: AD,
  nsupE: CD,
  nsupe: wD,
  nsupset: SD,
  nsupseteq: RD,
  nsupseteqq: DD,
  ntgl: TD,
  Ntilde: MD,
  ntilde: ND,
  ntlg: ID,
  ntriangleleft: LD,
  ntrianglelefteq: qD,
  ntriangleright: FD,
  ntrianglerighteq: OD,
  Nu: BD,
  nu: PD,
  num: zD,
  numero: $D,
  numsp: UD,
  nvap: HD,
  nvdash: GD,
  nvDash: VD,
  nVdash: ZD,
  nVDash: jD,
  nvge: KD,
  nvgt: WD,
  nvHarr: YD,
  nvinfin: JD,
  nvlArr: XD,
  nvle: QD,
  nvlt: eT,
  nvltrie: nT,
  nvrArr: tT,
  nvrtrie: rT,
  nvsim: oT,
  nwarhk: sT,
  nwarr: cT,
  nwArr: iT,
  nwarrow: aT,
  nwnear: lT,
  Oacute: uT,
  oacute: fT,
  oast: hT,
  Ocirc: pT,
  ocirc: dT,
  ocir: gT,
  Ocy: _T,
  ocy: mT,
  odash: bT,
  Odblac: vT,
  odblac: kT,
  odiv: xT,
  odot: yT,
  odsold: ET,
  OElig: AT,
  oelig: CT,
  ofcir: wT,
  Ofr: ST,
  ofr: RT,
  ogon: DT,
  Ograve: TT,
  ograve: MT,
  ogt: NT,
  ohbar: IT,
  ohm: LT,
  oint: qT,
  olarr: FT,
  olcir: OT,
  olcross: BT,
  oline: PT,
  olt: zT,
  Omacr: $T,
  omacr: UT,
  Omega: HT,
  omega: GT,
  Omicron: VT,
  omicron: ZT,
  omid: jT,
  ominus: KT,
  Oopf: WT,
  oopf: YT,
  opar: JT,
  OpenCurlyDoubleQuote: XT,
  OpenCurlyQuote: QT,
  operp: e2,
  oplus: n2,
  orarr: t2,
  Or: r2,
  or: o2,
  ord: s2,
  order: c2,
  orderof: i2,
  ordf: a2,
  ordm: l2,
  origof: u2,
  oror: f2,
  orslope: h2,
  orv: p2,
  oS: d2,
  Oscr: g2,
  oscr: _2,
  Oslash: m2,
  oslash: b2,
  osol: v2,
  Otilde: k2,
  otilde: x2,
  otimesas: y2,
  Otimes: E2,
  otimes: A2,
  Ouml: C2,
  ouml: w2,
  ovbar: S2,
  OverBar: R2,
  OverBrace: D2,
  OverBracket: T2,
  OverParenthesis: M2,
  para: N2,
  parallel: I2,
  par: L2,
  parsim: q2,
  parsl: F2,
  part: O2,
  PartialD: B2,
  Pcy: P2,
  pcy: z2,
  percnt: $2,
  period: U2,
  permil: H2,
  perp: G2,
  pertenk: V2,
  Pfr: Z2,
  pfr: j2,
  Phi: K2,
  phi: W2,
  phiv: Y2,
  phmmat: J2,
  phone: X2,
  Pi: Q2,
  pi: eM,
  pitchfork: nM,
  piv: tM,
  planck: rM,
  planckh: oM,
  plankv: sM,
  plusacir: cM,
  plusb: iM,
  pluscir: aM,
  plus: lM,
  plusdo: uM,
  plusdu: fM,
  pluse: hM,
  PlusMinus: pM,
  plusmn: dM,
  plussim: gM,
  plustwo: _M,
  pm: mM,
  Poincareplane: bM,
  pointint: vM,
  popf: kM,
  Popf: xM,
  pound: yM,
  prap: EM,
  Pr: AM,
  pr: CM,
  prcue: wM,
  precapprox: SM,
  prec: RM,
  preccurlyeq: DM,
  Precedes: TM,
  PrecedesEqual: MM,
  PrecedesSlantEqual: NM,
  PrecedesTilde: IM,
  preceq: LM,
  precnapprox: qM,
  precneqq: FM,
  precnsim: OM,
  pre: BM,
  prE: PM,
  precsim: zM,
  prime: $M,
  Prime: UM,
  primes: HM,
  prnap: GM,
  prnE: VM,
  prnsim: ZM,
  prod: jM,
  Product: KM,
  profalar: WM,
  profline: YM,
  profsurf: JM,
  prop: XM,
  Proportional: QM,
  Proportion: eN,
  propto: nN,
  prsim: tN,
  prurel: rN,
  Pscr: oN,
  pscr: sN,
  Psi: cN,
  psi: iN,
  puncsp: aN,
  Qfr: lN,
  qfr: uN,
  qint: fN,
  qopf: hN,
  Qopf: pN,
  qprime: dN,
  Qscr: gN,
  qscr: _N,
  quaternions: mN,
  quatint: bN,
  quest: vN,
  questeq: kN,
  quot: xN,
  QUOT: yN,
  rAarr: EN,
  race: AN,
  Racute: CN,
  racute: wN,
  radic: SN,
  raemptyv: RN,
  rang: DN,
  Rang: TN,
  rangd: MN,
  range: NN,
  rangle: IN,
  raquo: LN,
  rarrap: qN,
  rarrb: FN,
  rarrbfs: ON,
  rarrc: BN,
  rarr: PN,
  Rarr: zN,
  rArr: $N,
  rarrfs: UN,
  rarrhk: HN,
  rarrlp: GN,
  rarrpl: VN,
  rarrsim: ZN,
  Rarrtl: jN,
  rarrtl: KN,
  rarrw: WN,
  ratail: YN,
  rAtail: JN,
  ratio: XN,
  rationals: QN,
  rbarr: eI,
  rBarr: nI,
  RBarr: tI,
  rbbrk: rI,
  rbrace: oI,
  rbrack: sI,
  rbrke: cI,
  rbrksld: iI,
  rbrkslu: aI,
  Rcaron: lI,
  rcaron: uI,
  Rcedil: fI,
  rcedil: hI,
  rceil: pI,
  rcub: dI,
  Rcy: gI,
  rcy: _I,
  rdca: mI,
  rdldhar: bI,
  rdquo: vI,
  rdquor: kI,
  rdsh: xI,
  real: yI,
  realine: EI,
  realpart: AI,
  reals: CI,
  Re: wI,
  rect: SI,
  reg: RI,
  REG: DI,
  ReverseElement: TI,
  ReverseEquilibrium: MI,
  ReverseUpEquilibrium: NI,
  rfisht: II,
  rfloor: LI,
  rfr: qI,
  Rfr: FI,
  rHar: OI,
  rhard: BI,
  rharu: PI,
  rharul: zI,
  Rho: $I,
  rho: UI,
  rhov: HI,
  RightAngleBracket: GI,
  RightArrowBar: VI,
  rightarrow: ZI,
  RightArrow: jI,
  Rightarrow: KI,
  RightArrowLeftArrow: WI,
  rightarrowtail: YI,
  RightCeiling: JI,
  RightDoubleBracket: XI,
  RightDownTeeVector: QI,
  RightDownVectorBar: eL,
  RightDownVector: nL,
  RightFloor: tL,
  rightharpoondown: rL,
  rightharpoonup: oL,
  rightleftarrows: sL,
  rightleftharpoons: cL,
  rightrightarrows: iL,
  rightsquigarrow: aL,
  RightTeeArrow: lL,
  RightTee: uL,
  RightTeeVector: fL,
  rightthreetimes: hL,
  RightTriangleBar: pL,
  RightTriangle: dL,
  RightTriangleEqual: gL,
  RightUpDownVector: _L,
  RightUpTeeVector: mL,
  RightUpVectorBar: bL,
  RightUpVector: vL,
  RightVectorBar: kL,
  RightVector: xL,
  ring: yL,
  risingdotseq: EL,
  rlarr: AL,
  rlhar: CL,
  rlm: wL,
  rmoustache: SL,
  rmoust: RL,
  rnmid: DL,
  roang: TL,
  roarr: ML,
  robrk: NL,
  ropar: IL,
  ropf: LL,
  Ropf: qL,
  roplus: FL,
  rotimes: OL,
  RoundImplies: BL,
  rpar: PL,
  rpargt: zL,
  rppolint: $L,
  rrarr: UL,
  Rrightarrow: HL,
  rsaquo: GL,
  rscr: VL,
  Rscr: ZL,
  rsh: jL,
  Rsh: KL,
  rsqb: WL,
  rsquo: YL,
  rsquor: JL,
  rthree: XL,
  rtimes: QL,
  rtri: eq,
  rtrie: nq,
  rtrif: tq,
  rtriltri: rq,
  RuleDelayed: oq,
  ruluhar: sq,
  rx: cq,
  Sacute: iq,
  sacute: aq,
  sbquo: lq,
  scap: uq,
  Scaron: fq,
  scaron: hq,
  Sc: pq,
  sc: dq,
  sccue: gq,
  sce: _q,
  scE: mq,
  Scedil: bq,
  scedil: vq,
  Scirc: kq,
  scirc: xq,
  scnap: yq,
  scnE: Eq,
  scnsim: Aq,
  scpolint: Cq,
  scsim: wq,
  Scy: Sq,
  scy: Rq,
  sdotb: Dq,
  sdot: Tq,
  sdote: Mq,
  searhk: Nq,
  searr: Iq,
  seArr: Lq,
  searrow: qq,
  sect: Fq,
  semi: Oq,
  seswar: Bq,
  setminus: Pq,
  setmn: zq,
  sext: $q,
  Sfr: Uq,
  sfr: Hq,
  sfrown: Gq,
  sharp: Vq,
  SHCHcy: Zq,
  shchcy: jq,
  SHcy: Kq,
  shcy: Wq,
  ShortDownArrow: Yq,
  ShortLeftArrow: Jq,
  shortmid: Xq,
  shortparallel: Qq,
  ShortRightArrow: eF,
  ShortUpArrow: nF,
  shy: tF,
  Sigma: rF,
  sigma: oF,
  sigmaf: sF,
  sigmav: cF,
  sim: iF,
  simdot: aF,
  sime: lF,
  simeq: uF,
  simg: fF,
  simgE: hF,
  siml: pF,
  simlE: dF,
  simne: gF,
  simplus: _F,
  simrarr: mF,
  slarr: bF,
  SmallCircle: vF,
  smallsetminus: kF,
  smashp: xF,
  smeparsl: yF,
  smid: EF,
  smile: AF,
  smt: CF,
  smte: wF,
  smtes: SF,
  SOFTcy: RF,
  softcy: DF,
  solbar: TF,
  solb: MF,
  sol: NF,
  Sopf: IF,
  sopf: LF,
  spades: qF,
  spadesuit: FF,
  spar: OF,
  sqcap: BF,
  sqcaps: PF,
  sqcup: zF,
  sqcups: $F,
  Sqrt: UF,
  sqsub: HF,
  sqsube: GF,
  sqsubset: VF,
  sqsubseteq: ZF,
  sqsup: jF,
  sqsupe: KF,
  sqsupset: WF,
  sqsupseteq: YF,
  square: JF,
  Square: XF,
  SquareIntersection: QF,
  SquareSubset: eO,
  SquareSubsetEqual: nO,
  SquareSuperset: tO,
  SquareSupersetEqual: rO,
  SquareUnion: oO,
  squarf: sO,
  squ: cO,
  squf: iO,
  srarr: aO,
  Sscr: lO,
  sscr: uO,
  ssetmn: fO,
  ssmile: hO,
  sstarf: pO,
  Star: dO,
  star: gO,
  starf: _O,
  straightepsilon: mO,
  straightphi: bO,
  strns: vO,
  sub: kO,
  Sub: xO,
  subdot: yO,
  subE: EO,
  sube: AO,
  subedot: CO,
  submult: wO,
  subnE: SO,
  subne: RO,
  subplus: DO,
  subrarr: TO,
  subset: MO,
  Subset: NO,
  subseteq: IO,
  subseteqq: LO,
  SubsetEqual: qO,
  subsetneq: FO,
  subsetneqq: OO,
  subsim: BO,
  subsub: PO,
  subsup: zO,
  succapprox: $O,
  succ: UO,
  succcurlyeq: HO,
  Succeeds: GO,
  SucceedsEqual: VO,
  SucceedsSlantEqual: ZO,
  SucceedsTilde: jO,
  succeq: KO,
  succnapprox: WO,
  succneqq: YO,
  succnsim: JO,
  succsim: XO,
  SuchThat: QO,
  sum: eB,
  Sum: nB,
  sung: tB,
  sup1: rB,
  sup2: oB,
  sup3: sB,
  sup: cB,
  Sup: iB,
  supdot: aB,
  supdsub: lB,
  supE: uB,
  supe: fB,
  supedot: hB,
  Superset: pB,
  SupersetEqual: dB,
  suphsol: gB,
  suphsub: _B,
  suplarr: mB,
  supmult: bB,
  supnE: vB,
  supne: kB,
  supplus: xB,
  supset: yB,
  Supset: EB,
  supseteq: AB,
  supseteqq: CB,
  supsetneq: wB,
  supsetneqq: SB,
  supsim: RB,
  supsub: DB,
  supsup: TB,
  swarhk: MB,
  swarr: NB,
  swArr: IB,
  swarrow: LB,
  swnwar: qB,
  szlig: FB,
  Tab: OB,
  target: BB,
  Tau: PB,
  tau: zB,
  tbrk: $B,
  Tcaron: UB,
  tcaron: HB,
  Tcedil: GB,
  tcedil: VB,
  Tcy: ZB,
  tcy: jB,
  tdot: KB,
  telrec: WB,
  Tfr: YB,
  tfr: JB,
  there4: XB,
  therefore: QB,
  Therefore: eP,
  Theta: nP,
  theta: tP,
  thetasym: rP,
  thetav: oP,
  thickapprox: sP,
  thicksim: cP,
  ThickSpace: iP,
  ThinSpace: aP,
  thinsp: lP,
  thkap: uP,
  thksim: fP,
  THORN: hP,
  thorn: pP,
  tilde: dP,
  Tilde: gP,
  TildeEqual: _P,
  TildeFullEqual: mP,
  TildeTilde: bP,
  timesbar: vP,
  timesb: kP,
  times: xP,
  timesd: yP,
  tint: EP,
  toea: AP,
  topbot: CP,
  topcir: wP,
  top: SP,
  Topf: RP,
  topf: DP,
  topfork: TP,
  tosa: MP,
  tprime: NP,
  trade: IP,
  TRADE: LP,
  triangle: qP,
  triangledown: FP,
  triangleleft: OP,
  trianglelefteq: BP,
  triangleq: PP,
  triangleright: zP,
  trianglerighteq: $P,
  tridot: UP,
  trie: HP,
  triminus: GP,
  TripleDot: VP,
  triplus: ZP,
  trisb: jP,
  tritime: KP,
  trpezium: WP,
  Tscr: YP,
  tscr: JP,
  TScy: XP,
  tscy: QP,
  TSHcy: ez,
  tshcy: nz,
  Tstrok: tz,
  tstrok: rz,
  twixt: oz,
  twoheadleftarrow: sz,
  twoheadrightarrow: cz,
  Uacute: iz,
  uacute: az,
  uarr: lz,
  Uarr: uz,
  uArr: fz,
  Uarrocir: hz,
  Ubrcy: pz,
  ubrcy: dz,
  Ubreve: gz,
  ubreve: _z,
  Ucirc: mz,
  ucirc: bz,
  Ucy: vz,
  ucy: kz,
  udarr: xz,
  Udblac: yz,
  udblac: Ez,
  udhar: Az,
  ufisht: Cz,
  Ufr: wz,
  ufr: Sz,
  Ugrave: Rz,
  ugrave: Dz,
  uHar: Tz,
  uharl: Mz,
  uharr: Nz,
  uhblk: Iz,
  ulcorn: Lz,
  ulcorner: qz,
  ulcrop: Fz,
  ultri: Oz,
  Umacr: Bz,
  umacr: Pz,
  uml: zz,
  UnderBar: $z,
  UnderBrace: Uz,
  UnderBracket: Hz,
  UnderParenthesis: Gz,
  Union: Vz,
  UnionPlus: Zz,
  Uogon: jz,
  uogon: Kz,
  Uopf: Wz,
  uopf: Yz,
  UpArrowBar: Jz,
  uparrow: Xz,
  UpArrow: Qz,
  Uparrow: e$,
  UpArrowDownArrow: n$,
  updownarrow: t$,
  UpDownArrow: r$,
  Updownarrow: o$,
  UpEquilibrium: s$,
  upharpoonleft: c$,
  upharpoonright: i$,
  uplus: a$,
  UpperLeftArrow: l$,
  UpperRightArrow: u$,
  upsi: f$,
  Upsi: h$,
  upsih: p$,
  Upsilon: d$,
  upsilon: g$,
  UpTeeArrow: _$,
  UpTee: m$,
  upuparrows: b$,
  urcorn: v$,
  urcorner: k$,
  urcrop: x$,
  Uring: y$,
  uring: E$,
  urtri: A$,
  Uscr: C$,
  uscr: w$,
  utdot: S$,
  Utilde: R$,
  utilde: D$,
  utri: T$,
  utrif: M$,
  uuarr: N$,
  Uuml: I$,
  uuml: L$,
  uwangle: q$,
  vangrt: F$,
  varepsilon: O$,
  varkappa: B$,
  varnothing: P$,
  varphi: z$,
  varpi: $$,
  varpropto: U$,
  varr: H$,
  vArr: G$,
  varrho: V$,
  varsigma: Z$,
  varsubsetneq: j$,
  varsubsetneqq: K$,
  varsupsetneq: W$,
  varsupsetneqq: Y$,
  vartheta: J$,
  vartriangleleft: X$,
  vartriangleright: Q$,
  vBar: e3,
  Vbar: n3,
  vBarv: t3,
  Vcy: r3,
  vcy: o3,
  vdash: s3,
  vDash: c3,
  Vdash: i3,
  VDash: a3,
  Vdashl: l3,
  veebar: u3,
  vee: f3,
  Vee: h3,
  veeeq: p3,
  vellip: d3,
  verbar: g3,
  Verbar: _3,
  vert: m3,
  Vert: b3,
  VerticalBar: v3,
  VerticalLine: k3,
  VerticalSeparator: x3,
  VerticalTilde: y3,
  VeryThinSpace: E3,
  Vfr: A3,
  vfr: C3,
  vltri: w3,
  vnsub: S3,
  vnsup: R3,
  Vopf: D3,
  vopf: T3,
  vprop: M3,
  vrtri: N3,
  Vscr: I3,
  vscr: L3,
  vsubnE: q3,
  vsubne: F3,
  vsupnE: O3,
  vsupne: B3,
  Vvdash: P3,
  vzigzag: z3,
  Wcirc: $3,
  wcirc: U3,
  wedbar: H3,
  wedge: G3,
  Wedge: V3,
  wedgeq: Z3,
  weierp: j3,
  Wfr: K3,
  wfr: W3,
  Wopf: Y3,
  wopf: J3,
  wp: X3,
  wr: Q3,
  wreath: eU,
  Wscr: nU,
  wscr: tU,
  xcap: rU,
  xcirc: oU,
  xcup: sU,
  xdtri: cU,
  Xfr: iU,
  xfr: aU,
  xharr: lU,
  xhArr: uU,
  Xi: fU,
  xi: hU,
  xlarr: pU,
  xlArr: dU,
  xmap: gU,
  xnis: _U,
  xodot: mU,
  Xopf: bU,
  xopf: vU,
  xoplus: kU,
  xotime: xU,
  xrarr: yU,
  xrArr: EU,
  Xscr: AU,
  xscr: CU,
  xsqcup: wU,
  xuplus: SU,
  xutri: RU,
  xvee: DU,
  xwedge: TU,
  Yacute: MU,
  yacute: NU,
  YAcy: IU,
  yacy: LU,
  Ycirc: qU,
  ycirc: FU,
  Ycy: OU,
  ycy: BU,
  yen: PU,
  Yfr: zU,
  yfr: $U,
  YIcy: UU,
  yicy: HU,
  Yopf: GU,
  yopf: VU,
  Yscr: ZU,
  yscr: jU,
  YUcy: KU,
  yucy: WU,
  yuml: YU,
  Yuml: JU,
  Zacute: XU,
  zacute: QU,
  Zcaron: e5,
  zcaron: n5,
  Zcy: t5,
  zcy: r5,
  Zdot: o5,
  zdot: s5,
  zeetrf: c5,
  ZeroWidthSpace: i5,
  Zeta: a5,
  zeta: l5,
  zfr: u5,
  Zfr: f5,
  ZHcy: h5,
  zhcy: p5,
  zigrarr: d5,
  zopf: g5,
  Zopf: _5,
  Zscr: m5,
  zscr: b5,
  zwj: v5,
  zwnj: k5
};
var wn, mr;
function ts() {
  return mr || (mr = 1, wn = x5), wn;
}
var Sn, br;
function Pt() {
  return br || (br = 1, Sn = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/), Sn;
}
var $e = {}, Rn, vr;
function y5() {
  if (vr) return Rn;
  vr = 1;
  var c = {};
  function n(e) {
    var t, r, s = c[e];
    if (s)
      return s;
    for (s = c[e] = [], t = 0; t < 128; t++)
      r = String.fromCharCode(t), /^[0-9a-z]$/i.test(r) ? s.push(r) : s.push("%" + ("0" + t.toString(16).toUpperCase()).slice(-2));
    for (t = 0; t < e.length; t++)
      s[e.charCodeAt(t)] = e[t];
    return s;
  }
  function o(e, t, r) {
    var s, i, a, l, f, u = "";
    for (typeof t != "string" && (r = t, t = o.defaultChars), typeof r > "u" && (r = !0), f = n(t), s = 0, i = e.length; s < i; s++) {
      if (a = e.charCodeAt(s), r && a === 37 && s + 2 < i && /^[0-9a-f]{2}$/i.test(e.slice(s + 1, s + 3))) {
        u += e.slice(s, s + 3), s += 2;
        continue;
      }
      if (a < 128) {
        u += f[a];
        continue;
      }
      if (a >= 55296 && a <= 57343) {
        if (a >= 55296 && a <= 56319 && s + 1 < i && (l = e.charCodeAt(s + 1), l >= 56320 && l <= 57343)) {
          u += encodeURIComponent(e[s] + e[s + 1]), s++;
          continue;
        }
        u += "%EF%BF%BD";
        continue;
      }
      u += encodeURIComponent(e[s]);
    }
    return u;
  }
  return o.defaultChars = ";/?:@&=+$,-_.!~*'()#", o.componentChars = "-_.!~*'()", Rn = o, Rn;
}
var Dn, kr;
function E5() {
  if (kr) return Dn;
  kr = 1;
  var c = {};
  function n(e) {
    var t, r, s = c[e];
    if (s)
      return s;
    for (s = c[e] = [], t = 0; t < 128; t++)
      r = String.fromCharCode(t), s.push(r);
    for (t = 0; t < e.length; t++)
      r = e.charCodeAt(t), s[r] = "%" + ("0" + r.toString(16).toUpperCase()).slice(-2);
    return s;
  }
  function o(e, t) {
    var r;
    return typeof t != "string" && (t = o.defaultChars), r = n(t), e.replace(/(%[a-f0-9]{2})+/gi, function(s) {
      var i, a, l, f, u, d, h, _ = "";
      for (i = 0, a = s.length; i < a; i += 3) {
        if (l = parseInt(s.slice(i + 1, i + 3), 16), l < 128) {
          _ += r[l];
          continue;
        }
        if ((l & 224) === 192 && i + 3 < a && (f = parseInt(s.slice(i + 4, i + 6), 16), (f & 192) === 128)) {
          h = l << 6 & 1984 | f & 63, h < 128 ? _ += "��" : _ += String.fromCharCode(h), i += 3;
          continue;
        }
        if ((l & 240) === 224 && i + 6 < a && (f = parseInt(s.slice(i + 4, i + 6), 16), u = parseInt(s.slice(i + 7, i + 9), 16), (f & 192) === 128 && (u & 192) === 128)) {
          h = l << 12 & 61440 | f << 6 & 4032 | u & 63, h < 2048 || h >= 55296 && h <= 57343 ? _ += "���" : _ += String.fromCharCode(h), i += 6;
          continue;
        }
        if ((l & 248) === 240 && i + 9 < a && (f = parseInt(s.slice(i + 4, i + 6), 16), u = parseInt(s.slice(i + 7, i + 9), 16), d = parseInt(s.slice(i + 10, i + 12), 16), (f & 192) === 128 && (u & 192) === 128 && (d & 192) === 128)) {
          h = l << 18 & 1835008 | f << 12 & 258048 | u << 6 & 4032 | d & 63, h < 65536 || h > 1114111 ? _ += "����" : (h -= 65536, _ += String.fromCharCode(55296 + (h >> 10), 56320 + (h & 1023))), i += 9;
          continue;
        }
        _ += "�";
      }
      return _;
    });
  }
  return o.defaultChars = ";/?:@&=+$,#", o.componentChars = "", Dn = o, Dn;
}
var Tn, xr;
function A5() {
  return xr || (xr = 1, Tn = function(n) {
    var o = "";
    return o += n.protocol || "", o += n.slashes ? "//" : "", o += n.auth ? n.auth + "@" : "", n.hostname && n.hostname.indexOf(":") !== -1 ? o += "[" + n.hostname + "]" : o += n.hostname || "", o += n.port ? ":" + n.port : "", o += n.pathname || "", o += n.search || "", o += n.hash || "", o;
  }), Tn;
}
var Mn, yr;
function C5() {
  if (yr) return Mn;
  yr = 1;
  function c() {
    this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
  }
  var n = /^([a-z0-9.+-]+:)/i, o = /:[0-9]*$/, e = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, t = ["<", ">", '"', "`", " ", "\r", `
`, "	"], r = ["{", "}", "|", "\\", "^", "`"].concat(t), s = ["'"].concat(r), i = ["%", "/", "?", ";", "#"].concat(s), a = ["/", "?", "#"], l = 255, f = /^[+a-z0-9A-Z_-]{0,63}$/, u = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, d = {
    javascript: !0,
    "javascript:": !0
  }, h = {
    http: !0,
    https: !0,
    ftp: !0,
    gopher: !0,
    file: !0,
    "http:": !0,
    "https:": !0,
    "ftp:": !0,
    "gopher:": !0,
    "file:": !0
  };
  function _(v, E) {
    if (v && v instanceof c)
      return v;
    var b = new c();
    return b.parse(v, E), b;
  }
  return c.prototype.parse = function(v, E) {
    var b, x, g, m, k, y = v;
    if (y = y.trim(), !E && v.split("#").length === 1) {
      var I = e.exec(y);
      if (I)
        return this.pathname = I[1], I[2] && (this.search = I[2]), this;
    }
    var w = n.exec(y);
    if (w && (w = w[0], g = w.toLowerCase(), this.protocol = w, y = y.substr(w.length)), (E || w || y.match(/^\/\/[^@\/]+@[^@\/]+/)) && (k = y.substr(0, 2) === "//", k && !(w && d[w]) && (y = y.substr(2), this.slashes = !0)), !d[w] && (k || w && !h[w])) {
      var D = -1;
      for (b = 0; b < a.length; b++)
        m = y.indexOf(a[b]), m !== -1 && (D === -1 || m < D) && (D = m);
      var R, q;
      for (D === -1 ? q = y.lastIndexOf("@") : q = y.lastIndexOf("@", D), q !== -1 && (R = y.slice(0, q), y = y.slice(q + 1), this.auth = R), D = -1, b = 0; b < i.length; b++)
        m = y.indexOf(i[b]), m !== -1 && (D === -1 || m < D) && (D = m);
      D === -1 && (D = y.length), y[D - 1] === ":" && D--;
      var V = y.slice(0, D);
      y = y.slice(D), this.parseHost(V), this.hostname = this.hostname || "";
      var ne = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!ne) {
        var C = this.hostname.split(/\./);
        for (b = 0, x = C.length; b < x; b++) {
          var M = C[b];
          if (M && !M.match(f)) {
            for (var $ = "", J = 0, Z = M.length; J < Z; J++)
              M.charCodeAt(J) > 127 ? $ += "x" : $ += M[J];
            if (!$.match(f)) {
              var X = C.slice(0, b), O = C.slice(b + 1), ae = M.match(u);
              ae && (X.push(ae[1]), O.unshift(ae[2])), O.length && (y = O.join(".") + y), this.hostname = X.join(".");
              break;
            }
          }
        }
      }
      this.hostname.length > l && (this.hostname = ""), ne && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
    }
    var de = y.indexOf("#");
    de !== -1 && (this.hash = y.substr(de), y = y.slice(0, de));
    var Ee = y.indexOf("?");
    return Ee !== -1 && (this.search = y.substr(Ee), y = y.slice(0, Ee)), y && (this.pathname = y), h[g] && this.hostname && !this.pathname && (this.pathname = ""), this;
  }, c.prototype.parseHost = function(v) {
    var E = o.exec(v);
    E && (E = E[0], E !== ":" && (this.port = E.substr(1)), v = v.substr(0, v.length - E.length)), v && (this.hostname = v);
  }, Mn = _, Mn;
}
var Er;
function rs() {
  return Er || (Er = 1, $e.encode = y5(), $e.decode = E5(), $e.format = A5(), $e.parse = C5()), $e;
}
var Be = {}, Nn, Ar;
function os() {
  return Ar || (Ar = 1, Nn = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), Nn;
}
var In, Cr;
function ss() {
  return Cr || (Cr = 1, In = /[\0-\x1F\x7F-\x9F]/), In;
}
var Ln, wr;
function w5() {
  return wr || (wr = 1, Ln = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), Ln;
}
var qn, Sr;
function cs() {
  return Sr || (Sr = 1, qn = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), qn;
}
var Rr;
function S5() {
  return Rr || (Rr = 1, Be.Any = os(), Be.Cc = ss(), Be.Cf = w5(), Be.P = Pt(), Be.Z = cs()), Be;
}
var Dr;
function Q() {
  return Dr || (Dr = 1, function(c) {
    function n(C) {
      return Object.prototype.toString.call(C);
    }
    function o(C) {
      return n(C) === "[object String]";
    }
    var e = Object.prototype.hasOwnProperty;
    function t(C, M) {
      return e.call(C, M);
    }
    function r(C) {
      var M = Array.prototype.slice.call(arguments, 1);
      return M.forEach(function($) {
        if ($) {
          if (typeof $ != "object")
            throw new TypeError($ + "must be object");
          Object.keys($).forEach(function(J) {
            C[J] = $[J];
          });
        }
      }), C;
    }
    function s(C, M, $) {
      return [].concat(C.slice(0, M), $, C.slice(M + 1));
    }
    function i(C) {
      return !(C >= 55296 && C <= 57343 || C >= 64976 && C <= 65007 || (C & 65535) === 65535 || (C & 65535) === 65534 || C >= 0 && C <= 8 || C === 11 || C >= 14 && C <= 31 || C >= 127 && C <= 159 || C > 1114111);
    }
    function a(C) {
      if (C > 65535) {
        C -= 65536;
        var M = 55296 + (C >> 10), $ = 56320 + (C & 1023);
        return String.fromCharCode(M, $);
      }
      return String.fromCharCode(C);
    }
    var l = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, f = /&([a-z#][a-z0-9]{1,31});/gi, u = new RegExp(l.source + "|" + f.source, "gi"), d = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i, h = ts();
    function _(C, M) {
      var $;
      return t(h, M) ? h[M] : M.charCodeAt(0) === 35 && d.test(M) && ($ = M[1].toLowerCase() === "x" ? parseInt(M.slice(2), 16) : parseInt(M.slice(1), 10), i($)) ? a($) : C;
    }
    function v(C) {
      return C.indexOf("\\") < 0 ? C : C.replace(l, "$1");
    }
    function E(C) {
      return C.indexOf("\\") < 0 && C.indexOf("&") < 0 ? C : C.replace(u, function(M, $, J) {
        return $ || _(M, J);
      });
    }
    var b = /[&<>"]/, x = /[&<>"]/g, g = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function m(C) {
      return g[C];
    }
    function k(C) {
      return b.test(C) ? C.replace(x, m) : C;
    }
    var y = /[.?*+^$[\]\\(){}|-]/g;
    function I(C) {
      return C.replace(y, "\\$&");
    }
    function w(C) {
      switch (C) {
        case 9:
        case 32:
          return !0;
      }
      return !1;
    }
    function D(C) {
      if (C >= 8192 && C <= 8202)
        return !0;
      switch (C) {
        case 9:
        // \t
        case 10:
        // \n
        case 11:
        // \v
        case 12:
        // \f
        case 13:
        // \r
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return !0;
      }
      return !1;
    }
    var R = Pt();
    function q(C) {
      return R.test(C);
    }
    function V(C) {
      switch (C) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return !0;
        default:
          return !1;
      }
    }
    function ne(C) {
      return C = C.trim().replace(/\s+/g, " "), "ẞ".toLowerCase() === "Ṿ" && (C = C.replace(/ẞ/g, "ß")), C.toLowerCase().toUpperCase();
    }
    c.lib = {}, c.lib.mdurl = rs(), c.lib.ucmicro = S5(), c.assign = r, c.isString = o, c.has = t, c.unescapeMd = v, c.unescapeAll = E, c.isValidEntityCode = i, c.fromCodePoint = a, c.escapeHtml = k, c.arrayReplaceAt = s, c.isSpace = w, c.isWhiteSpace = D, c.isMdAsciiPunct = V, c.isPunctChar = q, c.escapeRE = I, c.normalizeReference = ne;
  }(Cn)), Cn;
}
var Ke = {}, Fn, Tr;
function R5() {
  return Tr || (Tr = 1, Fn = function(n, o, e) {
    var t, r, s, i, a = -1, l = n.posMax, f = n.pos;
    for (n.pos = o + 1, t = 1; n.pos < l; ) {
      if (s = n.src.charCodeAt(n.pos), s === 93 && (t--, t === 0)) {
        r = !0;
        break;
      }
      if (i = n.pos, n.md.inline.skipToken(n), s === 91) {
        if (i === n.pos - 1)
          t++;
        else if (e)
          return n.pos = f, -1;
      }
    }
    return r && (a = n.pos), n.pos = f, a;
  }), Fn;
}
var On, Mr;
function D5() {
  if (Mr) return On;
  Mr = 1;
  var c = Q().unescapeAll;
  return On = function(o, e, t) {
    var r, s, i = e, a = {
      ok: !1,
      pos: 0,
      lines: 0,
      str: ""
    };
    if (o.charCodeAt(i) === 60) {
      for (i++; i < t; ) {
        if (r = o.charCodeAt(i), r === 10 || r === 60)
          return a;
        if (r === 62)
          return a.pos = i + 1, a.str = c(o.slice(e + 1, i)), a.ok = !0, a;
        if (r === 92 && i + 1 < t) {
          i += 2;
          continue;
        }
        i++;
      }
      return a;
    }
    for (s = 0; i < t && (r = o.charCodeAt(i), !(r === 32 || r < 32 || r === 127)); ) {
      if (r === 92 && i + 1 < t) {
        if (o.charCodeAt(i + 1) === 32)
          break;
        i += 2;
        continue;
      }
      if (r === 40 && (s++, s > 32))
        return a;
      if (r === 41) {
        if (s === 0)
          break;
        s--;
      }
      i++;
    }
    return e === i || s !== 0 || (a.str = c(o.slice(e, i)), a.pos = i, a.ok = !0), a;
  }, On;
}
var Bn, Nr;
function T5() {
  if (Nr) return Bn;
  Nr = 1;
  var c = Q().unescapeAll;
  return Bn = function(o, e, t) {
    var r, s, i = 0, a = e, l = {
      ok: !1,
      pos: 0,
      lines: 0,
      str: ""
    };
    if (a >= t || (s = o.charCodeAt(a), s !== 34 && s !== 39 && s !== 40))
      return l;
    for (a++, s === 40 && (s = 41); a < t; ) {
      if (r = o.charCodeAt(a), r === s)
        return l.pos = a + 1, l.lines = i, l.str = c(o.slice(e + 1, a)), l.ok = !0, l;
      if (r === 40 && s === 41)
        return l;
      r === 10 ? i++ : r === 92 && a + 1 < t && (a++, o.charCodeAt(a) === 10 && i++), a++;
    }
    return l;
  }, Bn;
}
var Ir;
function M5() {
  return Ir || (Ir = 1, Ke.parseLinkLabel = R5(), Ke.parseLinkDestination = D5(), Ke.parseLinkTitle = T5()), Ke;
}
var Pn, Lr;
function N5() {
  if (Lr) return Pn;
  Lr = 1;
  var c = Q().assign, n = Q().unescapeAll, o = Q().escapeHtml, e = {};
  e.code_inline = function(r, s, i, a, l) {
    var f = r[s];
    return "<code" + l.renderAttrs(f) + ">" + o(f.content) + "</code>";
  }, e.code_block = function(r, s, i, a, l) {
    var f = r[s];
    return "<pre" + l.renderAttrs(f) + "><code>" + o(r[s].content) + `</code></pre>
`;
  }, e.fence = function(r, s, i, a, l) {
    var f = r[s], u = f.info ? n(f.info).trim() : "", d = "", h = "", _, v, E, b, x;
    return u && (E = u.split(/(\s+)/g), d = E[0], h = E.slice(2).join("")), i.highlight ? _ = i.highlight(f.content, d, h) || o(f.content) : _ = o(f.content), _.indexOf("<pre") === 0 ? _ + `
` : u ? (v = f.attrIndex("class"), b = f.attrs ? f.attrs.slice() : [], v < 0 ? b.push(["class", i.langPrefix + d]) : (b[v] = b[v].slice(), b[v][1] += " " + i.langPrefix + d), x = {
      attrs: b
    }, "<pre><code" + l.renderAttrs(x) + ">" + _ + `</code></pre>
`) : "<pre><code" + l.renderAttrs(f) + ">" + _ + `</code></pre>
`;
  }, e.image = function(r, s, i, a, l) {
    var f = r[s];
    return f.attrs[f.attrIndex("alt")][1] = l.renderInlineAsText(f.children, i, a), l.renderToken(r, s, i);
  }, e.hardbreak = function(r, s, i) {
    return i.xhtmlOut ? `<br />
` : `<br>
`;
  }, e.softbreak = function(r, s, i) {
    return i.breaks ? i.xhtmlOut ? `<br />
` : `<br>
` : `
`;
  }, e.text = function(r, s) {
    return o(r[s].content);
  }, e.html_block = function(r, s) {
    return r[s].content;
  }, e.html_inline = function(r, s) {
    return r[s].content;
  };
  function t() {
    this.rules = c({}, e);
  }
  return t.prototype.renderAttrs = function(s) {
    var i, a, l;
    if (!s.attrs)
      return "";
    for (l = "", i = 0, a = s.attrs.length; i < a; i++)
      l += " " + o(s.attrs[i][0]) + '="' + o(s.attrs[i][1]) + '"';
    return l;
  }, t.prototype.renderToken = function(s, i, a) {
    var l, f = "", u = !1, d = s[i];
    return d.hidden ? "" : (d.block && d.nesting !== -1 && i && s[i - 1].hidden && (f += `
`), f += (d.nesting === -1 ? "</" : "<") + d.tag, f += this.renderAttrs(d), d.nesting === 0 && a.xhtmlOut && (f += " /"), d.block && (u = !0, d.nesting === 1 && i + 1 < s.length && (l = s[i + 1], (l.type === "inline" || l.hidden || l.nesting === -1 && l.tag === d.tag) && (u = !1))), f += u ? `>
` : ">", f);
  }, t.prototype.renderInline = function(r, s, i) {
    for (var a, l = "", f = this.rules, u = 0, d = r.length; u < d; u++)
      a = r[u].type, typeof f[a] < "u" ? l += f[a](r, u, s, i, this) : l += this.renderToken(r, u, s);
    return l;
  }, t.prototype.renderInlineAsText = function(r, s, i) {
    for (var a = "", l = 0, f = r.length; l < f; l++)
      r[l].type === "text" ? a += r[l].content : r[l].type === "image" ? a += this.renderInlineAsText(r[l].children, s, i) : r[l].type === "softbreak" && (a += `
`);
    return a;
  }, t.prototype.render = function(r, s, i) {
    var a, l, f, u = "", d = this.rules;
    for (a = 0, l = r.length; a < l; a++)
      f = r[a].type, f === "inline" ? u += this.renderInline(r[a].children, s, i) : typeof d[f] < "u" ? u += d[f](r, a, s, i, this) : u += this.renderToken(r, a, s, i);
    return u;
  }, Pn = t, Pn;
}
var zn, qr;
function zt() {
  if (qr) return zn;
  qr = 1;
  function c() {
    this.__rules__ = [], this.__cache__ = null;
  }
  return c.prototype.__find__ = function(n) {
    for (var o = 0; o < this.__rules__.length; o++)
      if (this.__rules__[o].name === n)
        return o;
    return -1;
  }, c.prototype.__compile__ = function() {
    var n = this, o = [""];
    n.__rules__.forEach(function(e) {
      e.enabled && e.alt.forEach(function(t) {
        o.indexOf(t) < 0 && o.push(t);
      });
    }), n.__cache__ = {}, o.forEach(function(e) {
      n.__cache__[e] = [], n.__rules__.forEach(function(t) {
        t.enabled && (e && t.alt.indexOf(e) < 0 || n.__cache__[e].push(t.fn));
      });
    });
  }, c.prototype.at = function(n, o, e) {
    var t = this.__find__(n), r = e || {};
    if (t === -1)
      throw new Error("Parser rule not found: " + n);
    this.__rules__[t].fn = o, this.__rules__[t].alt = r.alt || [], this.__cache__ = null;
  }, c.prototype.before = function(n, o, e, t) {
    var r = this.__find__(n), s = t || {};
    if (r === -1)
      throw new Error("Parser rule not found: " + n);
    this.__rules__.splice(r, 0, {
      name: o,
      enabled: !0,
      fn: e,
      alt: s.alt || []
    }), this.__cache__ = null;
  }, c.prototype.after = function(n, o, e, t) {
    var r = this.__find__(n), s = t || {};
    if (r === -1)
      throw new Error("Parser rule not found: " + n);
    this.__rules__.splice(r + 1, 0, {
      name: o,
      enabled: !0,
      fn: e,
      alt: s.alt || []
    }), this.__cache__ = null;
  }, c.prototype.push = function(n, o, e) {
    var t = e || {};
    this.__rules__.push({
      name: n,
      enabled: !0,
      fn: o,
      alt: t.alt || []
    }), this.__cache__ = null;
  }, c.prototype.enable = function(n, o) {
    Array.isArray(n) || (n = [n]);
    var e = [];
    return n.forEach(function(t) {
      var r = this.__find__(t);
      if (r < 0) {
        if (o)
          return;
        throw new Error("Rules manager: invalid rule name " + t);
      }
      this.__rules__[r].enabled = !0, e.push(t);
    }, this), this.__cache__ = null, e;
  }, c.prototype.enableOnly = function(n, o) {
    Array.isArray(n) || (n = [n]), this.__rules__.forEach(function(e) {
      e.enabled = !1;
    }), this.enable(n, o);
  }, c.prototype.disable = function(n, o) {
    Array.isArray(n) || (n = [n]);
    var e = [];
    return n.forEach(function(t) {
      var r = this.__find__(t);
      if (r < 0) {
        if (o)
          return;
        throw new Error("Rules manager: invalid rule name " + t);
      }
      this.__rules__[r].enabled = !1, e.push(t);
    }, this), this.__cache__ = null, e;
  }, c.prototype.getRules = function(n) {
    return this.__cache__ === null && this.__compile__(), this.__cache__[n] || [];
  }, zn = c, zn;
}
var $n, Fr;
function I5() {
  if (Fr) return $n;
  Fr = 1;
  var c = /\r\n?|\n/g, n = /\0/g;
  return $n = function(e) {
    var t;
    t = e.src.replace(c, `
`), t = t.replace(n, "�"), e.src = t;
  }, $n;
}
var Un, Or;
function L5() {
  return Or || (Or = 1, Un = function(n) {
    var o;
    n.inlineMode ? (o = new n.Token("inline", "", 0), o.content = n.src, o.map = [0, 1], o.children = [], n.tokens.push(o)) : n.md.block.parse(n.src, n.md, n.env, n.tokens);
  }), Un;
}
var Hn, Br;
function q5() {
  return Br || (Br = 1, Hn = function(n) {
    var o = n.tokens, e, t, r;
    for (t = 0, r = o.length; t < r; t++)
      e = o[t], e.type === "inline" && n.md.inline.parse(e.content, n.md, n.env, e.children);
  }), Hn;
}
var Gn, Pr;
function F5() {
  if (Pr) return Gn;
  Pr = 1;
  var c = Q().arrayReplaceAt;
  function n(e) {
    return /^<a[>\s]/i.test(e);
  }
  function o(e) {
    return /^<\/a\s*>/i.test(e);
  }
  return Gn = function(t) {
    var r, s, i, a, l, f, u, d, h, _, v, E, b, x, g, m, k = t.tokens, y;
    if (t.md.options.linkify) {
      for (s = 0, i = k.length; s < i; s++)
        if (!(k[s].type !== "inline" || !t.md.linkify.pretest(k[s].content)))
          for (a = k[s].children, b = 0, r = a.length - 1; r >= 0; r--) {
            if (f = a[r], f.type === "link_close") {
              for (r--; a[r].level !== f.level && a[r].type !== "link_open"; )
                r--;
              continue;
            }
            if (f.type === "html_inline" && (n(f.content) && b > 0 && b--, o(f.content) && b++), !(b > 0) && f.type === "text" && t.md.linkify.test(f.content)) {
              for (h = f.content, y = t.md.linkify.match(h), u = [], E = f.level, v = 0, y.length > 0 && y[0].index === 0 && r > 0 && a[r - 1].type === "text_special" && (y = y.slice(1)), d = 0; d < y.length; d++)
                x = y[d].url, g = t.md.normalizeLink(x), t.md.validateLink(g) && (m = y[d].text, y[d].schema ? y[d].schema === "mailto:" && !/^mailto:/i.test(m) ? m = t.md.normalizeLinkText("mailto:" + m).replace(/^mailto:/, "") : m = t.md.normalizeLinkText(m) : m = t.md.normalizeLinkText("http://" + m).replace(/^http:\/\//, ""), _ = y[d].index, _ > v && (l = new t.Token("text", "", 0), l.content = h.slice(v, _), l.level = E, u.push(l)), l = new t.Token("link_open", "a", 1), l.attrs = [["href", g]], l.level = E++, l.markup = "linkify", l.info = "auto", u.push(l), l = new t.Token("text", "", 0), l.content = m, l.level = E, u.push(l), l = new t.Token("link_close", "a", -1), l.level = --E, l.markup = "linkify", l.info = "auto", u.push(l), v = y[d].lastIndex);
              v < h.length && (l = new t.Token("text", "", 0), l.content = h.slice(v), l.level = E, u.push(l)), k[s].children = a = c(a, r, u);
            }
          }
    }
  }, Gn;
}
var Vn, zr;
function O5() {
  if (zr) return Vn;
  zr = 1;
  var c = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, n = /\((c|tm|r)\)/i, o = /\((c|tm|r)\)/ig, e = {
    c: "©",
    r: "®",
    tm: "™"
  };
  function t(i, a) {
    return e[a.toLowerCase()];
  }
  function r(i) {
    var a, l, f = 0;
    for (a = i.length - 1; a >= 0; a--)
      l = i[a], l.type === "text" && !f && (l.content = l.content.replace(o, t)), l.type === "link_open" && l.info === "auto" && f--, l.type === "link_close" && l.info === "auto" && f++;
  }
  function s(i) {
    var a, l, f = 0;
    for (a = i.length - 1; a >= 0; a--)
      l = i[a], l.type === "text" && !f && c.test(l.content) && (l.content = l.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–")), l.type === "link_open" && l.info === "auto" && f--, l.type === "link_close" && l.info === "auto" && f++;
  }
  return Vn = function(a) {
    var l;
    if (a.md.options.typographer)
      for (l = a.tokens.length - 1; l >= 0; l--)
        a.tokens[l].type === "inline" && (n.test(a.tokens[l].content) && r(a.tokens[l].children), c.test(a.tokens[l].content) && s(a.tokens[l].children));
  }, Vn;
}
var Zn, $r;
function B5() {
  if ($r) return Zn;
  $r = 1;
  var c = Q().isWhiteSpace, n = Q().isPunctChar, o = Q().isMdAsciiPunct, e = /['"]/, t = /['"]/g, r = "’";
  function s(a, l, f) {
    return a.slice(0, l) + f + a.slice(l + 1);
  }
  function i(a, l) {
    var f, u, d, h, _, v, E, b, x, g, m, k, y, I, w, D, R, q, V, ne, C;
    for (V = [], f = 0; f < a.length; f++) {
      for (u = a[f], E = a[f].level, R = V.length - 1; R >= 0 && !(V[R].level <= E); R--)
        ;
      if (V.length = R + 1, u.type === "text") {
        d = u.content, _ = 0, v = d.length;
        e:
          for (; _ < v && (t.lastIndex = _, h = t.exec(d), !!h); ) {
            if (w = D = !0, _ = h.index + 1, q = h[0] === "'", x = 32, h.index - 1 >= 0)
              x = d.charCodeAt(h.index - 1);
            else
              for (R = f - 1; R >= 0 && !(a[R].type === "softbreak" || a[R].type === "hardbreak"); R--)
                if (a[R].content) {
                  x = a[R].content.charCodeAt(a[R].content.length - 1);
                  break;
                }
            if (g = 32, _ < v)
              g = d.charCodeAt(_);
            else
              for (R = f + 1; R < a.length && !(a[R].type === "softbreak" || a[R].type === "hardbreak"); R++)
                if (a[R].content) {
                  g = a[R].content.charCodeAt(0);
                  break;
                }
            if (m = o(x) || n(String.fromCharCode(x)), k = o(g) || n(String.fromCharCode(g)), y = c(x), I = c(g), I ? w = !1 : k && (y || m || (w = !1)), y ? D = !1 : m && (I || k || (D = !1)), g === 34 && h[0] === '"' && x >= 48 && x <= 57 && (D = w = !1), w && D && (w = m, D = k), !w && !D) {
              q && (u.content = s(u.content, h.index, r));
              continue;
            }
            if (D) {
              for (R = V.length - 1; R >= 0 && (b = V[R], !(V[R].level < E)); R--)
                if (b.single === q && V[R].level === E) {
                  b = V[R], q ? (ne = l.md.options.quotes[2], C = l.md.options.quotes[3]) : (ne = l.md.options.quotes[0], C = l.md.options.quotes[1]), u.content = s(u.content, h.index, C), a[b.token].content = s(
                    a[b.token].content,
                    b.pos,
                    ne
                  ), _ += C.length - 1, b.token === f && (_ += ne.length - 1), d = u.content, v = d.length, V.length = R;
                  continue e;
                }
            }
            w ? V.push({
              token: f,
              pos: h.index,
              single: q,
              level: E
            }) : D && q && (u.content = s(u.content, h.index, r));
          }
      }
    }
  }
  return Zn = function(l) {
    var f;
    if (l.md.options.typographer)
      for (f = l.tokens.length - 1; f >= 0; f--)
        l.tokens[f].type !== "inline" || !e.test(l.tokens[f].content) || i(l.tokens[f].children, l);
  }, Zn;
}
var jn, Ur;
function P5() {
  return Ur || (Ur = 1, jn = function(n) {
    var o, e, t, r, s, i, a = n.tokens;
    for (o = 0, e = a.length; o < e; o++)
      if (a[o].type === "inline") {
        for (t = a[o].children, s = t.length, r = 0; r < s; r++)
          t[r].type === "text_special" && (t[r].type = "text");
        for (r = i = 0; r < s; r++)
          t[r].type === "text" && r + 1 < s && t[r + 1].type === "text" ? t[r + 1].content = t[r].content + t[r + 1].content : (r !== i && (t[i] = t[r]), i++);
        r !== i && (t.length = i);
      }
  }), jn;
}
var Kn, Hr;
function $t() {
  if (Hr) return Kn;
  Hr = 1;
  function c(n, o, e) {
    this.type = n, this.tag = o, this.attrs = null, this.map = null, this.nesting = e, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
  }
  return c.prototype.attrIndex = function(o) {
    var e, t, r;
    if (!this.attrs)
      return -1;
    for (e = this.attrs, t = 0, r = e.length; t < r; t++)
      if (e[t][0] === o)
        return t;
    return -1;
  }, c.prototype.attrPush = function(o) {
    this.attrs ? this.attrs.push(o) : this.attrs = [o];
  }, c.prototype.attrSet = function(o, e) {
    var t = this.attrIndex(o), r = [o, e];
    t < 0 ? this.attrPush(r) : this.attrs[t] = r;
  }, c.prototype.attrGet = function(o) {
    var e = this.attrIndex(o), t = null;
    return e >= 0 && (t = this.attrs[e][1]), t;
  }, c.prototype.attrJoin = function(o, e) {
    var t = this.attrIndex(o);
    t < 0 ? this.attrPush([o, e]) : this.attrs[t][1] = this.attrs[t][1] + " " + e;
  }, Kn = c, Kn;
}
var Wn, Gr;
function z5() {
  if (Gr) return Wn;
  Gr = 1;
  var c = $t();
  function n(o, e, t) {
    this.src = o, this.env = t, this.tokens = [], this.inlineMode = !1, this.md = e;
  }
  return n.prototype.Token = c, Wn = n, Wn;
}
var Yn, Vr;
function $5() {
  if (Vr) return Yn;
  Vr = 1;
  var c = zt(), n = [
    ["normalize", I5()],
    ["block", L5()],
    ["inline", q5()],
    ["linkify", F5()],
    ["replacements", O5()],
    ["smartquotes", B5()],
    // `text_join` finds `text_special` tokens (for escape sequences)
    // and joins them with the rest of the text
    ["text_join", P5()]
  ];
  function o() {
    this.ruler = new c();
    for (var e = 0; e < n.length; e++)
      this.ruler.push(n[e][0], n[e][1]);
  }
  return o.prototype.process = function(e) {
    var t, r, s;
    for (s = this.ruler.getRules(""), t = 0, r = s.length; t < r; t++)
      s[t](e);
  }, o.prototype.State = z5(), Yn = o, Yn;
}
var Jn, Zr;
function U5() {
  if (Zr) return Jn;
  Zr = 1;
  var c = Q().isSpace;
  function n(e, t) {
    var r = e.bMarks[t] + e.tShift[t], s = e.eMarks[t];
    return e.src.slice(r, s);
  }
  function o(e) {
    var t = [], r = 0, s = e.length, i, a = !1, l = 0, f = "";
    for (i = e.charCodeAt(r); r < s; )
      i === 124 && (a ? (f += e.substring(l, r - 1), l = r) : (t.push(f + e.substring(l, r)), f = "", l = r + 1)), a = i === 92, r++, i = e.charCodeAt(r);
    return t.push(f + e.substring(l)), t;
  }
  return Jn = function(t, r, s, i) {
    var a, l, f, u, d, h, _, v, E, b, x, g, m, k, y, I, w, D;
    if (r + 2 > s || (h = r + 1, t.sCount[h] < t.blkIndent) || t.sCount[h] - t.blkIndent >= 4 || (f = t.bMarks[h] + t.tShift[h], f >= t.eMarks[h]) || (w = t.src.charCodeAt(f++), w !== 124 && w !== 45 && w !== 58) || f >= t.eMarks[h] || (D = t.src.charCodeAt(f++), D !== 124 && D !== 45 && D !== 58 && !c(D)) || w === 45 && c(D))
      return !1;
    for (; f < t.eMarks[h]; ) {
      if (a = t.src.charCodeAt(f), a !== 124 && a !== 45 && a !== 58 && !c(a))
        return !1;
      f++;
    }
    for (l = n(t, r + 1), _ = l.split("|"), b = [], u = 0; u < _.length; u++) {
      if (x = _[u].trim(), !x) {
        if (u === 0 || u === _.length - 1)
          continue;
        return !1;
      }
      if (!/^:?-+:?$/.test(x))
        return !1;
      x.charCodeAt(x.length - 1) === 58 ? b.push(x.charCodeAt(0) === 58 ? "center" : "right") : x.charCodeAt(0) === 58 ? b.push("left") : b.push("");
    }
    if (l = n(t, r).trim(), l.indexOf("|") === -1 || t.sCount[r] - t.blkIndent >= 4 || (_ = o(l), _.length && _[0] === "" && _.shift(), _.length && _[_.length - 1] === "" && _.pop(), v = _.length, v === 0 || v !== b.length))
      return !1;
    if (i)
      return !0;
    for (k = t.parentType, t.parentType = "table", I = t.md.block.ruler.getRules("blockquote"), E = t.push("table_open", "table", 1), E.map = g = [r, 0], E = t.push("thead_open", "thead", 1), E.map = [r, r + 1], E = t.push("tr_open", "tr", 1), E.map = [r, r + 1], u = 0; u < _.length; u++)
      E = t.push("th_open", "th", 1), b[u] && (E.attrs = [["style", "text-align:" + b[u]]]), E = t.push("inline", "", 0), E.content = _[u].trim(), E.children = [], E = t.push("th_close", "th", -1);
    for (E = t.push("tr_close", "tr", -1), E = t.push("thead_close", "thead", -1), h = r + 2; h < s && !(t.sCount[h] < t.blkIndent); h++) {
      for (y = !1, u = 0, d = I.length; u < d; u++)
        if (I[u](t, h, s, !0)) {
          y = !0;
          break;
        }
      if (y || (l = n(t, h).trim(), !l) || t.sCount[h] - t.blkIndent >= 4)
        break;
      for (_ = o(l), _.length && _[0] === "" && _.shift(), _.length && _[_.length - 1] === "" && _.pop(), h === r + 2 && (E = t.push("tbody_open", "tbody", 1), E.map = m = [r + 2, 0]), E = t.push("tr_open", "tr", 1), E.map = [h, h + 1], u = 0; u < v; u++)
        E = t.push("td_open", "td", 1), b[u] && (E.attrs = [["style", "text-align:" + b[u]]]), E = t.push("inline", "", 0), E.content = _[u] ? _[u].trim() : "", E.children = [], E = t.push("td_close", "td", -1);
      E = t.push("tr_close", "tr", -1);
    }
    return m && (E = t.push("tbody_close", "tbody", -1), m[1] = h), E = t.push("table_close", "table", -1), g[1] = h, t.parentType = k, t.line = h, !0;
  }, Jn;
}
var Xn, jr;
function H5() {
  return jr || (jr = 1, Xn = function(n, o, e) {
    var t, r, s;
    if (n.sCount[o] - n.blkIndent < 4)
      return !1;
    for (r = t = o + 1; t < e; ) {
      if (n.isEmpty(t)) {
        t++;
        continue;
      }
      if (n.sCount[t] - n.blkIndent >= 4) {
        t++, r = t;
        continue;
      }
      break;
    }
    return n.line = r, s = n.push("code_block", "code", 0), s.content = n.getLines(o, r, 4 + n.blkIndent, !1) + `
`, s.map = [o, n.line], !0;
  }), Xn;
}
var Qn, Kr;
function G5() {
  return Kr || (Kr = 1, Qn = function(n, o, e, t) {
    var r, s, i, a, l, f, u, d = !1, h = n.bMarks[o] + n.tShift[o], _ = n.eMarks[o];
    if (n.sCount[o] - n.blkIndent >= 4 || h + 3 > _ || (r = n.src.charCodeAt(h), r !== 126 && r !== 96) || (l = h, h = n.skipChars(h, r), s = h - l, s < 3) || (u = n.src.slice(l, h), i = n.src.slice(h, _), r === 96 && i.indexOf(String.fromCharCode(r)) >= 0))
      return !1;
    if (t)
      return !0;
    for (a = o; a++, !(a >= e || (h = l = n.bMarks[a] + n.tShift[a], _ = n.eMarks[a], h < _ && n.sCount[a] < n.blkIndent)); )
      if (n.src.charCodeAt(h) === r && !(n.sCount[a] - n.blkIndent >= 4) && (h = n.skipChars(h, r), !(h - l < s) && (h = n.skipSpaces(h), !(h < _)))) {
        d = !0;
        break;
      }
    return s = n.sCount[o], n.line = a + (d ? 1 : 0), f = n.push("fence", "code", 0), f.info = i, f.content = n.getLines(o + 1, a, s, !0), f.markup = u, f.map = [o, n.line], !0;
  }), Qn;
}
var et, Wr;
function V5() {
  if (Wr) return et;
  Wr = 1;
  var c = Q().isSpace;
  return et = function(o, e, t, r) {
    var s, i, a, l, f, u, d, h, _, v, E, b, x, g, m, k, y, I, w, D, R = o.lineMax, q = o.bMarks[e] + o.tShift[e], V = o.eMarks[e];
    if (o.sCount[e] - o.blkIndent >= 4 || o.src.charCodeAt(q) !== 62)
      return !1;
    if (r)
      return !0;
    for (v = [], E = [], g = [], m = [], I = o.md.block.ruler.getRules("blockquote"), x = o.parentType, o.parentType = "blockquote", h = e; h < t && (D = o.sCount[h] < o.blkIndent, q = o.bMarks[h] + o.tShift[h], V = o.eMarks[h], !(q >= V)); h++) {
      if (o.src.charCodeAt(q++) === 62 && !D) {
        for (l = o.sCount[h] + 1, o.src.charCodeAt(q) === 32 ? (q++, l++, s = !1, k = !0) : o.src.charCodeAt(q) === 9 ? (k = !0, (o.bsCount[h] + l) % 4 === 3 ? (q++, l++, s = !1) : s = !0) : k = !1, _ = l, v.push(o.bMarks[h]), o.bMarks[h] = q; q < V && (i = o.src.charCodeAt(q), c(i)); ) {
          i === 9 ? _ += 4 - (_ + o.bsCount[h] + (s ? 1 : 0)) % 4 : _++;
          q++;
        }
        u = q >= V, E.push(o.bsCount[h]), o.bsCount[h] = o.sCount[h] + 1 + (k ? 1 : 0), g.push(o.sCount[h]), o.sCount[h] = _ - l, m.push(o.tShift[h]), o.tShift[h] = q - o.bMarks[h];
        continue;
      }
      if (u)
        break;
      for (y = !1, a = 0, f = I.length; a < f; a++)
        if (I[a](o, h, t, !0)) {
          y = !0;
          break;
        }
      if (y) {
        o.lineMax = h, o.blkIndent !== 0 && (v.push(o.bMarks[h]), E.push(o.bsCount[h]), m.push(o.tShift[h]), g.push(o.sCount[h]), o.sCount[h] -= o.blkIndent);
        break;
      }
      v.push(o.bMarks[h]), E.push(o.bsCount[h]), m.push(o.tShift[h]), g.push(o.sCount[h]), o.sCount[h] = -1;
    }
    for (b = o.blkIndent, o.blkIndent = 0, w = o.push("blockquote_open", "blockquote", 1), w.markup = ">", w.map = d = [e, 0], o.md.block.tokenize(o, e, h), w = o.push("blockquote_close", "blockquote", -1), w.markup = ">", o.lineMax = R, o.parentType = x, d[1] = o.line, a = 0; a < m.length; a++)
      o.bMarks[a + e] = v[a], o.tShift[a + e] = m[a], o.sCount[a + e] = g[a], o.bsCount[a + e] = E[a];
    return o.blkIndent = b, !0;
  }, et;
}
var nt, Yr;
function Z5() {
  if (Yr) return nt;
  Yr = 1;
  var c = Q().isSpace;
  return nt = function(o, e, t, r) {
    var s, i, a, l, f = o.bMarks[e] + o.tShift[e], u = o.eMarks[e];
    if (o.sCount[e] - o.blkIndent >= 4 || (s = o.src.charCodeAt(f++), s !== 42 && s !== 45 && s !== 95))
      return !1;
    for (i = 1; f < u; ) {
      if (a = o.src.charCodeAt(f++), a !== s && !c(a))
        return !1;
      a === s && i++;
    }
    return i < 3 ? !1 : (r || (o.line = e + 1, l = o.push("hr", "hr", 0), l.map = [e, o.line], l.markup = Array(i + 1).join(String.fromCharCode(s))), !0);
  }, nt;
}
var tt, Jr;
function j5() {
  if (Jr) return tt;
  Jr = 1;
  var c = Q().isSpace;
  function n(t, r) {
    var s, i, a, l;
    return i = t.bMarks[r] + t.tShift[r], a = t.eMarks[r], s = t.src.charCodeAt(i++), s !== 42 && s !== 45 && s !== 43 || i < a && (l = t.src.charCodeAt(i), !c(l)) ? -1 : i;
  }
  function o(t, r) {
    var s, i = t.bMarks[r] + t.tShift[r], a = i, l = t.eMarks[r];
    if (a + 1 >= l || (s = t.src.charCodeAt(a++), s < 48 || s > 57))
      return -1;
    for (; ; ) {
      if (a >= l)
        return -1;
      if (s = t.src.charCodeAt(a++), s >= 48 && s <= 57) {
        if (a - i >= 10)
          return -1;
        continue;
      }
      if (s === 41 || s === 46)
        break;
      return -1;
    }
    return a < l && (s = t.src.charCodeAt(a), !c(s)) ? -1 : a;
  }
  function e(t, r) {
    var s, i, a = t.level + 2;
    for (s = r + 2, i = t.tokens.length - 2; s < i; s++)
      t.tokens[s].level === a && t.tokens[s].type === "paragraph_open" && (t.tokens[s + 2].hidden = !0, t.tokens[s].hidden = !0, s += 2);
  }
  return tt = function(r, s, i, a) {
    var l, f, u, d, h, _, v, E, b, x, g, m, k, y, I, w, D, R, q, V, ne, C, M, $, J, Z, X, O = s, ae = !1, de = !0;
    if (r.sCount[O] - r.blkIndent >= 4 || r.listIndent >= 0 && r.sCount[O] - r.listIndent >= 4 && r.sCount[O] < r.blkIndent)
      return !1;
    if (a && r.parentType === "paragraph" && r.sCount[O] >= r.blkIndent && (ae = !0), (C = o(r, O)) >= 0) {
      if (v = !0, $ = r.bMarks[O] + r.tShift[O], k = Number(r.src.slice($, C - 1)), ae && k !== 1) return !1;
    } else if ((C = n(r, O)) >= 0)
      v = !1;
    else
      return !1;
    if (ae && r.skipSpaces(C) >= r.eMarks[O])
      return !1;
    if (a)
      return !0;
    for (m = r.src.charCodeAt(C - 1), g = r.tokens.length, v ? (X = r.push("ordered_list_open", "ol", 1), k !== 1 && (X.attrs = [["start", k]])) : X = r.push("bullet_list_open", "ul", 1), X.map = x = [O, 0], X.markup = String.fromCharCode(m), M = !1, Z = r.md.block.ruler.getRules("list"), D = r.parentType, r.parentType = "list"; O < i; ) {
      for (ne = C, y = r.eMarks[O], _ = I = r.sCount[O] + C - (r.bMarks[O] + r.tShift[O]); ne < y; ) {
        if (l = r.src.charCodeAt(ne), l === 9)
          I += 4 - (I + r.bsCount[O]) % 4;
        else if (l === 32)
          I++;
        else
          break;
        ne++;
      }
      if (f = ne, f >= y ? h = 1 : h = I - _, h > 4 && (h = 1), d = _ + h, X = r.push("list_item_open", "li", 1), X.markup = String.fromCharCode(m), X.map = E = [O, 0], v && (X.info = r.src.slice($, C - 1)), V = r.tight, q = r.tShift[O], R = r.sCount[O], w = r.listIndent, r.listIndent = r.blkIndent, r.blkIndent = d, r.tight = !0, r.tShift[O] = f - r.bMarks[O], r.sCount[O] = I, f >= y && r.isEmpty(O + 1) ? r.line = Math.min(r.line + 2, i) : r.md.block.tokenize(r, O, i, !0), (!r.tight || M) && (de = !1), M = r.line - O > 1 && r.isEmpty(r.line - 1), r.blkIndent = r.listIndent, r.listIndent = w, r.tShift[O] = q, r.sCount[O] = R, r.tight = V, X = r.push("list_item_close", "li", -1), X.markup = String.fromCharCode(m), O = r.line, E[1] = O, O >= i || r.sCount[O] < r.blkIndent || r.sCount[O] - r.blkIndent >= 4)
        break;
      for (J = !1, u = 0, b = Z.length; u < b; u++)
        if (Z[u](r, O, i, !0)) {
          J = !0;
          break;
        }
      if (J)
        break;
      if (v) {
        if (C = o(r, O), C < 0)
          break;
        $ = r.bMarks[O] + r.tShift[O];
      } else if (C = n(r, O), C < 0)
        break;
      if (m !== r.src.charCodeAt(C - 1))
        break;
    }
    return v ? X = r.push("ordered_list_close", "ol", -1) : X = r.push("bullet_list_close", "ul", -1), X.markup = String.fromCharCode(m), x[1] = O, r.line = O, r.parentType = D, de && e(r, g), !0;
  }, tt;
}
var rt, Xr;
function K5() {
  if (Xr) return rt;
  Xr = 1;
  var c = Q().normalizeReference, n = Q().isSpace;
  return rt = function(e, t, r, s) {
    var i, a, l, f, u, d, h, _, v, E, b, x, g, m, k, y, I = 0, w = e.bMarks[t] + e.tShift[t], D = e.eMarks[t], R = t + 1;
    if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(w) !== 91)
      return !1;
    for (; ++w < D; )
      if (e.src.charCodeAt(w) === 93 && e.src.charCodeAt(w - 1) !== 92) {
        if (w + 1 === D || e.src.charCodeAt(w + 1) !== 58)
          return !1;
        break;
      }
    for (f = e.lineMax, k = e.md.block.ruler.getRules("reference"), E = e.parentType, e.parentType = "reference"; R < f && !e.isEmpty(R); R++)
      if (!(e.sCount[R] - e.blkIndent > 3) && !(e.sCount[R] < 0)) {
        for (m = !1, d = 0, h = k.length; d < h; d++)
          if (k[d](e, R, f, !0)) {
            m = !0;
            break;
          }
        if (m)
          break;
      }
    for (g = e.getLines(t, R, e.blkIndent, !1).trim(), D = g.length, w = 1; w < D; w++) {
      if (i = g.charCodeAt(w), i === 91)
        return !1;
      if (i === 93) {
        v = w;
        break;
      } else i === 10 ? I++ : i === 92 && (w++, w < D && g.charCodeAt(w) === 10 && I++);
    }
    if (v < 0 || g.charCodeAt(v + 1) !== 58)
      return !1;
    for (w = v + 2; w < D; w++)
      if (i = g.charCodeAt(w), i === 10)
        I++;
      else if (!n(i)) break;
    if (b = e.md.helpers.parseLinkDestination(g, w, D), !b.ok || (u = e.md.normalizeLink(b.str), !e.md.validateLink(u)))
      return !1;
    for (w = b.pos, I += b.lines, a = w, l = I, x = w; w < D; w++)
      if (i = g.charCodeAt(w), i === 10)
        I++;
      else if (!n(i)) break;
    for (b = e.md.helpers.parseLinkTitle(g, w, D), w < D && x !== w && b.ok ? (y = b.str, w = b.pos, I += b.lines) : (y = "", w = a, I = l); w < D && (i = g.charCodeAt(w), !!n(i)); )
      w++;
    if (w < D && g.charCodeAt(w) !== 10 && y)
      for (y = "", w = a, I = l; w < D && (i = g.charCodeAt(w), !!n(i)); )
        w++;
    return w < D && g.charCodeAt(w) !== 10 || (_ = c(g.slice(1, v)), !_) ? !1 : (s || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[_] > "u" && (e.env.references[_] = { title: y, href: u }), e.parentType = E, e.line = t + I + 1), !0);
  }, rt;
}
var ot, Qr;
function W5() {
  return Qr || (Qr = 1, ot = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "section",
    "source",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ]), ot;
}
var cn = {}, eo;
function is() {
  if (eo) return cn;
  eo = 1;
  var c = "[a-zA-Z_:][a-zA-Z0-9:._-]*", n = "[^\"'=<>`\\x00-\\x20]+", o = "'[^']*'", e = '"[^"]*"', t = "(?:" + n + "|" + o + "|" + e + ")", r = "(?:\\s+" + c + "(?:\\s*=\\s*" + t + ")?)", s = "<[A-Za-z][A-Za-z0-9\\-]*" + r + "*\\s*\\/?>", i = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", a = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", l = "<[?][\\s\\S]*?[?]>", f = "<![A-Z]+\\s+[^>]*>", u = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", d = new RegExp("^(?:" + s + "|" + i + "|" + a + "|" + l + "|" + f + "|" + u + ")"), h = new RegExp("^(?:" + s + "|" + i + ")");
  return cn.HTML_TAG_RE = d, cn.HTML_OPEN_CLOSE_TAG_RE = h, cn;
}
var st, no;
function Y5() {
  if (no) return st;
  no = 1;
  var c = W5(), n = is().HTML_OPEN_CLOSE_TAG_RE, o = [
    [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
    [/^<!--/, /-->/, !0],
    [/^<\?/, /\?>/, !0],
    [/^<![A-Z]/, />/, !0],
    [/^<!\[CDATA\[/, /\]\]>/, !0],
    [new RegExp("^</?(" + c.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
    [new RegExp(n.source + "\\s*$"), /^$/, !1]
  ];
  return st = function(t, r, s, i) {
    var a, l, f, u, d = t.bMarks[r] + t.tShift[r], h = t.eMarks[r];
    if (t.sCount[r] - t.blkIndent >= 4 || !t.md.options.html || t.src.charCodeAt(d) !== 60)
      return !1;
    for (u = t.src.slice(d, h), a = 0; a < o.length && !o[a][0].test(u); a++)
      ;
    if (a === o.length)
      return !1;
    if (i)
      return o[a][2];
    if (l = r + 1, !o[a][1].test(u)) {
      for (; l < s && !(t.sCount[l] < t.blkIndent); l++)
        if (d = t.bMarks[l] + t.tShift[l], h = t.eMarks[l], u = t.src.slice(d, h), o[a][1].test(u)) {
          u.length !== 0 && l++;
          break;
        }
    }
    return t.line = l, f = t.push("html_block", "", 0), f.map = [r, l], f.content = t.getLines(r, l, t.blkIndent, !0), !0;
  }, st;
}
var ct, to;
function J5() {
  if (to) return ct;
  to = 1;
  var c = Q().isSpace;
  return ct = function(o, e, t, r) {
    var s, i, a, l, f = o.bMarks[e] + o.tShift[e], u = o.eMarks[e];
    if (o.sCount[e] - o.blkIndent >= 4 || (s = o.src.charCodeAt(f), s !== 35 || f >= u))
      return !1;
    for (i = 1, s = o.src.charCodeAt(++f); s === 35 && f < u && i <= 6; )
      i++, s = o.src.charCodeAt(++f);
    return i > 6 || f < u && !c(s) ? !1 : (r || (u = o.skipSpacesBack(u, f), a = o.skipCharsBack(u, 35, f), a > f && c(o.src.charCodeAt(a - 1)) && (u = a), o.line = e + 1, l = o.push("heading_open", "h" + String(i), 1), l.markup = "########".slice(0, i), l.map = [e, o.line], l = o.push("inline", "", 0), l.content = o.src.slice(f, u).trim(), l.map = [e, o.line], l.children = [], l = o.push("heading_close", "h" + String(i), -1), l.markup = "########".slice(0, i)), !0);
  }, ct;
}
var it, ro;
function X5() {
  return ro || (ro = 1, it = function(n, o, e) {
    var t, r, s, i, a, l, f, u, d, h = o + 1, _, v = n.md.block.ruler.getRules("paragraph");
    if (n.sCount[o] - n.blkIndent >= 4)
      return !1;
    for (_ = n.parentType, n.parentType = "paragraph"; h < e && !n.isEmpty(h); h++)
      if (!(n.sCount[h] - n.blkIndent > 3)) {
        if (n.sCount[h] >= n.blkIndent && (l = n.bMarks[h] + n.tShift[h], f = n.eMarks[h], l < f && (d = n.src.charCodeAt(l), (d === 45 || d === 61) && (l = n.skipChars(l, d), l = n.skipSpaces(l), l >= f)))) {
          u = d === 61 ? 1 : 2;
          break;
        }
        if (!(n.sCount[h] < 0)) {
          for (r = !1, s = 0, i = v.length; s < i; s++)
            if (v[s](n, h, e, !0)) {
              r = !0;
              break;
            }
          if (r)
            break;
        }
      }
    return u ? (t = n.getLines(o, h, n.blkIndent, !1).trim(), n.line = h + 1, a = n.push("heading_open", "h" + String(u), 1), a.markup = String.fromCharCode(d), a.map = [o, n.line], a = n.push("inline", "", 0), a.content = t, a.map = [o, n.line - 1], a.children = [], a = n.push("heading_close", "h" + String(u), -1), a.markup = String.fromCharCode(d), n.parentType = _, !0) : !1;
  }), it;
}
var at, oo;
function Q5() {
  return oo || (oo = 1, at = function(n, o, e) {
    var t, r, s, i, a, l, f = o + 1, u = n.md.block.ruler.getRules("paragraph");
    for (l = n.parentType, n.parentType = "paragraph"; f < e && !n.isEmpty(f); f++)
      if (!(n.sCount[f] - n.blkIndent > 3) && !(n.sCount[f] < 0)) {
        for (r = !1, s = 0, i = u.length; s < i; s++)
          if (u[s](n, f, e, !0)) {
            r = !0;
            break;
          }
        if (r)
          break;
      }
    return t = n.getLines(o, f, n.blkIndent, !1).trim(), n.line = f, a = n.push("paragraph_open", "p", 1), a.map = [o, n.line], a = n.push("inline", "", 0), a.content = t, a.map = [o, n.line], a.children = [], a = n.push("paragraph_close", "p", -1), n.parentType = l, !0;
  }), at;
}
var lt, so;
function e4() {
  if (so) return lt;
  so = 1;
  var c = $t(), n = Q().isSpace;
  function o(e, t, r, s) {
    var i, a, l, f, u, d, h, _;
    for (this.src = e, this.md = t, this.env = r, this.tokens = s, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", a = this.src, _ = !1, l = f = d = h = 0, u = a.length; f < u; f++) {
      if (i = a.charCodeAt(f), !_)
        if (n(i)) {
          d++, i === 9 ? h += 4 - h % 4 : h++;
          continue;
        } else
          _ = !0;
      (i === 10 || f === u - 1) && (i !== 10 && f++, this.bMarks.push(l), this.eMarks.push(f), this.tShift.push(d), this.sCount.push(h), this.bsCount.push(0), _ = !1, d = 0, h = 0, l = f + 1);
    }
    this.bMarks.push(a.length), this.eMarks.push(a.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
  }
  return o.prototype.push = function(e, t, r) {
    var s = new c(e, t, r);
    return s.block = !0, r < 0 && this.level--, s.level = this.level, r > 0 && this.level++, this.tokens.push(s), s;
  }, o.prototype.isEmpty = function(t) {
    return this.bMarks[t] + this.tShift[t] >= this.eMarks[t];
  }, o.prototype.skipEmptyLines = function(t) {
    for (var r = this.lineMax; t < r && !(this.bMarks[t] + this.tShift[t] < this.eMarks[t]); t++)
      ;
    return t;
  }, o.prototype.skipSpaces = function(t) {
    for (var r, s = this.src.length; t < s && (r = this.src.charCodeAt(t), !!n(r)); t++)
      ;
    return t;
  }, o.prototype.skipSpacesBack = function(t, r) {
    if (t <= r)
      return t;
    for (; t > r; )
      if (!n(this.src.charCodeAt(--t)))
        return t + 1;
    return t;
  }, o.prototype.skipChars = function(t, r) {
    for (var s = this.src.length; t < s && this.src.charCodeAt(t) === r; t++)
      ;
    return t;
  }, o.prototype.skipCharsBack = function(t, r, s) {
    if (t <= s)
      return t;
    for (; t > s; )
      if (r !== this.src.charCodeAt(--t))
        return t + 1;
    return t;
  }, o.prototype.getLines = function(t, r, s, i) {
    var a, l, f, u, d, h, _, v = t;
    if (t >= r)
      return "";
    for (h = new Array(r - t), a = 0; v < r; v++, a++) {
      for (l = 0, _ = u = this.bMarks[v], v + 1 < r || i ? d = this.eMarks[v] + 1 : d = this.eMarks[v]; u < d && l < s; ) {
        if (f = this.src.charCodeAt(u), n(f))
          f === 9 ? l += 4 - (l + this.bsCount[v]) % 4 : l++;
        else if (u - _ < this.tShift[v])
          l++;
        else
          break;
        u++;
      }
      l > s ? h[a] = new Array(l - s + 1).join(" ") + this.src.slice(u, d) : h[a] = this.src.slice(u, d);
    }
    return h.join("");
  }, o.prototype.Token = c, lt = o, lt;
}
var ut, co;
function n4() {
  if (co) return ut;
  co = 1;
  var c = zt(), n = [
    // First 2 params - rule name & source. Secondary array - list of rules,
    // which can be terminated by this one.
    ["table", U5(), ["paragraph", "reference"]],
    ["code", H5()],
    ["fence", G5(), ["paragraph", "reference", "blockquote", "list"]],
    ["blockquote", V5(), ["paragraph", "reference", "blockquote", "list"]],
    ["hr", Z5(), ["paragraph", "reference", "blockquote", "list"]],
    ["list", j5(), ["paragraph", "reference", "blockquote"]],
    ["reference", K5()],
    ["html_block", Y5(), ["paragraph", "reference", "blockquote"]],
    ["heading", J5(), ["paragraph", "reference", "blockquote"]],
    ["lheading", X5()],
    ["paragraph", Q5()]
  ];
  function o() {
    this.ruler = new c();
    for (var e = 0; e < n.length; e++)
      this.ruler.push(n[e][0], n[e][1], { alt: (n[e][2] || []).slice() });
  }
  return o.prototype.tokenize = function(e, t, r) {
    for (var s, i, a, l = this.ruler.getRules(""), f = l.length, u = t, d = !1, h = e.md.options.maxNesting; u < r && (e.line = u = e.skipEmptyLines(u), !(u >= r || e.sCount[u] < e.blkIndent)); ) {
      if (e.level >= h) {
        e.line = r;
        break;
      }
      for (a = e.line, i = 0; i < f; i++)
        if (s = l[i](e, u, r, !1), s) {
          if (a >= e.line)
            throw new Error("block rule didn't increment state.line");
          break;
        }
      if (!s) throw new Error("none of the block rules matched");
      e.tight = !d, e.isEmpty(e.line - 1) && (d = !0), u = e.line, u < r && e.isEmpty(u) && (d = !0, u++, e.line = u);
    }
  }, o.prototype.parse = function(e, t, r, s) {
    var i;
    e && (i = new this.State(e, t, r, s), this.tokenize(i, i.line, i.lineMax));
  }, o.prototype.State = e4(), ut = o, ut;
}
var ft, io;
function t4() {
  if (io) return ft;
  io = 1;
  function c(n) {
    switch (n) {
      case 10:
      case 33:
      case 35:
      case 36:
      case 37:
      case 38:
      case 42:
      case 43:
      case 45:
      case 58:
      case 60:
      case 61:
      case 62:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 125:
      case 126:
        return !0;
      default:
        return !1;
    }
  }
  return ft = function(o, e) {
    for (var t = o.pos; t < o.posMax && !c(o.src.charCodeAt(t)); )
      t++;
    return t === o.pos ? !1 : (e || (o.pending += o.src.slice(o.pos, t)), o.pos = t, !0);
  }, ft;
}
var ht, ao;
function r4() {
  if (ao) return ht;
  ao = 1;
  var c = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
  return ht = function(o, e) {
    var t, r, s, i, a, l, f, u;
    return !o.md.options.linkify || o.linkLevel > 0 || (t = o.pos, r = o.posMax, t + 3 > r) || o.src.charCodeAt(t) !== 58 || o.src.charCodeAt(t + 1) !== 47 || o.src.charCodeAt(t + 2) !== 47 || (s = o.pending.match(c), !s) || (i = s[1], a = o.md.linkify.matchAtStart(o.src.slice(t - i.length)), !a) || (l = a.url, l.length <= i.length) || (l = l.replace(/\*+$/, ""), f = o.md.normalizeLink(l), !o.md.validateLink(f)) ? !1 : (e || (o.pending = o.pending.slice(0, -i.length), u = o.push("link_open", "a", 1), u.attrs = [["href", f]], u.markup = "linkify", u.info = "auto", u = o.push("text", "", 0), u.content = o.md.normalizeLinkText(l), u = o.push("link_close", "a", -1), u.markup = "linkify", u.info = "auto"), o.pos += l.length - i.length, !0);
  }, ht;
}
var pt, lo;
function o4() {
  if (lo) return pt;
  lo = 1;
  var c = Q().isSpace;
  return pt = function(o, e) {
    var t, r, s, i = o.pos;
    if (o.src.charCodeAt(i) !== 10)
      return !1;
    if (t = o.pending.length - 1, r = o.posMax, !e)
      if (t >= 0 && o.pending.charCodeAt(t) === 32)
        if (t >= 1 && o.pending.charCodeAt(t - 1) === 32) {
          for (s = t - 1; s >= 1 && o.pending.charCodeAt(s - 1) === 32; ) s--;
          o.pending = o.pending.slice(0, s), o.push("hardbreak", "br", 0);
        } else
          o.pending = o.pending.slice(0, -1), o.push("softbreak", "br", 0);
      else
        o.push("softbreak", "br", 0);
    for (i++; i < r && c(o.src.charCodeAt(i)); )
      i++;
    return o.pos = i, !0;
  }, pt;
}
var dt, uo;
function s4() {
  if (uo) return dt;
  uo = 1;
  for (var c = Q().isSpace, n = [], o = 0; o < 256; o++)
    n.push(0);
  return "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(e) {
    n[e.charCodeAt(0)] = 1;
  }), dt = function(t, r) {
    var s, i, a, l, f, u = t.pos, d = t.posMax;
    if (t.src.charCodeAt(u) !== 92 || (u++, u >= d)) return !1;
    if (s = t.src.charCodeAt(u), s === 10) {
      for (r || t.push("hardbreak", "br", 0), u++; u < d && (s = t.src.charCodeAt(u), !!c(s)); )
        u++;
      return t.pos = u, !0;
    }
    return l = t.src[u], s >= 55296 && s <= 56319 && u + 1 < d && (i = t.src.charCodeAt(u + 1), i >= 56320 && i <= 57343 && (l += t.src[u + 1], u++)), a = "\\" + l, r || (f = t.push("text_special", "", 0), s < 256 && n[s] !== 0 ? f.content = l : f.content = a, f.markup = a, f.info = "escape"), t.pos = u + 1, !0;
  }, dt;
}
var gt, fo;
function c4() {
  return fo || (fo = 1, gt = function(n, o) {
    var e, t, r, s, i, a, l, f, u = n.pos, d = n.src.charCodeAt(u);
    if (d !== 96)
      return !1;
    for (e = u, u++, t = n.posMax; u < t && n.src.charCodeAt(u) === 96; )
      u++;
    if (r = n.src.slice(e, u), l = r.length, n.backticksScanned && (n.backticks[l] || 0) <= e)
      return o || (n.pending += r), n.pos += l, !0;
    for (a = u; (i = n.src.indexOf("`", a)) !== -1; ) {
      for (a = i + 1; a < t && n.src.charCodeAt(a) === 96; )
        a++;
      if (f = a - i, f === l)
        return o || (s = n.push("code_inline", "code", 0), s.markup = r, s.content = n.src.slice(u, i).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), n.pos = a, !0;
      n.backticks[f] = i;
    }
    return n.backticksScanned = !0, o || (n.pending += r), n.pos += l, !0;
  }), gt;
}
var an = {}, ho;
function po() {
  if (ho) return an;
  ho = 1, an.tokenize = function(o, e) {
    var t, r, s, i, a, l = o.pos, f = o.src.charCodeAt(l);
    if (e || f !== 126 || (r = o.scanDelims(o.pos, !0), i = r.length, a = String.fromCharCode(f), i < 2))
      return !1;
    for (i % 2 && (s = o.push("text", "", 0), s.content = a, i--), t = 0; t < i; t += 2)
      s = o.push("text", "", 0), s.content = a + a, o.delimiters.push({
        marker: f,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        token: o.tokens.length - 1,
        end: -1,
        open: r.can_open,
        close: r.can_close
      });
    return o.pos += r.length, !0;
  };
  function c(n, o) {
    var e, t, r, s, i, a = [], l = o.length;
    for (e = 0; e < l; e++)
      r = o[e], r.marker === 126 && r.end !== -1 && (s = o[r.end], i = n.tokens[r.token], i.type = "s_open", i.tag = "s", i.nesting = 1, i.markup = "~~", i.content = "", i = n.tokens[s.token], i.type = "s_close", i.tag = "s", i.nesting = -1, i.markup = "~~", i.content = "", n.tokens[s.token - 1].type === "text" && n.tokens[s.token - 1].content === "~" && a.push(s.token - 1));
    for (; a.length; ) {
      for (e = a.pop(), t = e + 1; t < n.tokens.length && n.tokens[t].type === "s_close"; )
        t++;
      t--, e !== t && (i = n.tokens[t], n.tokens[t] = n.tokens[e], n.tokens[e] = i);
    }
  }
  return an.postProcess = function(o) {
    var e, t = o.tokens_meta, r = o.tokens_meta.length;
    for (c(o, o.delimiters), e = 0; e < r; e++)
      t[e] && t[e].delimiters && c(o, t[e].delimiters);
  }, an;
}
var ln = {}, go;
function _o() {
  if (go) return ln;
  go = 1, ln.tokenize = function(o, e) {
    var t, r, s, i = o.pos, a = o.src.charCodeAt(i);
    if (e || a !== 95 && a !== 42)
      return !1;
    for (r = o.scanDelims(o.pos, a === 42), t = 0; t < r.length; t++)
      s = o.push("text", "", 0), s.content = String.fromCharCode(a), o.delimiters.push({
        // Char code of the starting marker (number).
        //
        marker: a,
        // Total length of these series of delimiters.
        //
        length: r.length,
        // A position of the token this delimiter corresponds to.
        //
        token: o.tokens.length - 1,
        // If this delimiter is matched as a valid opener, `end` will be
        // equal to its position, otherwise it's `-1`.
        //
        end: -1,
        // Boolean flags that determine if this delimiter could open or close
        // an emphasis.
        //
        open: r.can_open,
        close: r.can_close
      });
    return o.pos += r.length, !0;
  };
  function c(n, o) {
    var e, t, r, s, i, a, l = o.length;
    for (e = l - 1; e >= 0; e--)
      t = o[e], !(t.marker !== 95 && t.marker !== 42) && t.end !== -1 && (r = o[t.end], a = e > 0 && o[e - 1].end === t.end + 1 && // check that first two markers match and adjacent
      o[e - 1].marker === t.marker && o[e - 1].token === t.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
      o[t.end + 1].token === r.token + 1, i = String.fromCharCode(t.marker), s = n.tokens[t.token], s.type = a ? "strong_open" : "em_open", s.tag = a ? "strong" : "em", s.nesting = 1, s.markup = a ? i + i : i, s.content = "", s = n.tokens[r.token], s.type = a ? "strong_close" : "em_close", s.tag = a ? "strong" : "em", s.nesting = -1, s.markup = a ? i + i : i, s.content = "", a && (n.tokens[o[e - 1].token].content = "", n.tokens[o[t.end + 1].token].content = "", e--));
  }
  return ln.postProcess = function(o) {
    var e, t = o.tokens_meta, r = o.tokens_meta.length;
    for (c(o, o.delimiters), e = 0; e < r; e++)
      t[e] && t[e].delimiters && c(o, t[e].delimiters);
  }, ln;
}
var _t, mo;
function i4() {
  if (mo) return _t;
  mo = 1;
  var c = Q().normalizeReference, n = Q().isSpace;
  return _t = function(e, t) {
    var r, s, i, a, l, f, u, d, h, _ = "", v = "", E = e.pos, b = e.posMax, x = e.pos, g = !0;
    if (e.src.charCodeAt(e.pos) !== 91 || (l = e.pos + 1, a = e.md.helpers.parseLinkLabel(e, e.pos, !0), a < 0))
      return !1;
    if (f = a + 1, f < b && e.src.charCodeAt(f) === 40) {
      for (g = !1, f++; f < b && (s = e.src.charCodeAt(f), !(!n(s) && s !== 10)); f++)
        ;
      if (f >= b)
        return !1;
      if (x = f, u = e.md.helpers.parseLinkDestination(e.src, f, e.posMax), u.ok) {
        for (_ = e.md.normalizeLink(u.str), e.md.validateLink(_) ? f = u.pos : _ = "", x = f; f < b && (s = e.src.charCodeAt(f), !(!n(s) && s !== 10)); f++)
          ;
        if (u = e.md.helpers.parseLinkTitle(e.src, f, e.posMax), f < b && x !== f && u.ok)
          for (v = u.str, f = u.pos; f < b && (s = e.src.charCodeAt(f), !(!n(s) && s !== 10)); f++)
            ;
      }
      (f >= b || e.src.charCodeAt(f) !== 41) && (g = !0), f++;
    }
    if (g) {
      if (typeof e.env.references > "u")
        return !1;
      if (f < b && e.src.charCodeAt(f) === 91 ? (x = f + 1, f = e.md.helpers.parseLinkLabel(e, f), f >= 0 ? i = e.src.slice(x, f++) : f = a + 1) : f = a + 1, i || (i = e.src.slice(l, a)), d = e.env.references[c(i)], !d)
        return e.pos = E, !1;
      _ = d.href, v = d.title;
    }
    return t || (e.pos = l, e.posMax = a, h = e.push("link_open", "a", 1), h.attrs = r = [["href", _]], v && r.push(["title", v]), e.linkLevel++, e.md.inline.tokenize(e), e.linkLevel--, h = e.push("link_close", "a", -1)), e.pos = f, e.posMax = b, !0;
  }, _t;
}
var mt, bo;
function a4() {
  if (bo) return mt;
  bo = 1;
  var c = Q().normalizeReference, n = Q().isSpace;
  return mt = function(e, t) {
    var r, s, i, a, l, f, u, d, h, _, v, E, b, x = "", g = e.pos, m = e.posMax;
    if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (f = e.pos + 2, l = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1), l < 0))
      return !1;
    if (u = l + 1, u < m && e.src.charCodeAt(u) === 40) {
      for (u++; u < m && (s = e.src.charCodeAt(u), !(!n(s) && s !== 10)); u++)
        ;
      if (u >= m)
        return !1;
      for (b = u, h = e.md.helpers.parseLinkDestination(e.src, u, e.posMax), h.ok && (x = e.md.normalizeLink(h.str), e.md.validateLink(x) ? u = h.pos : x = ""), b = u; u < m && (s = e.src.charCodeAt(u), !(!n(s) && s !== 10)); u++)
        ;
      if (h = e.md.helpers.parseLinkTitle(e.src, u, e.posMax), u < m && b !== u && h.ok)
        for (_ = h.str, u = h.pos; u < m && (s = e.src.charCodeAt(u), !(!n(s) && s !== 10)); u++)
          ;
      else
        _ = "";
      if (u >= m || e.src.charCodeAt(u) !== 41)
        return e.pos = g, !1;
      u++;
    } else {
      if (typeof e.env.references > "u")
        return !1;
      if (u < m && e.src.charCodeAt(u) === 91 ? (b = u + 1, u = e.md.helpers.parseLinkLabel(e, u), u >= 0 ? a = e.src.slice(b, u++) : u = l + 1) : u = l + 1, a || (a = e.src.slice(f, l)), d = e.env.references[c(a)], !d)
        return e.pos = g, !1;
      x = d.href, _ = d.title;
    }
    return t || (i = e.src.slice(f, l), e.md.inline.parse(
      i,
      e.md,
      e.env,
      E = []
    ), v = e.push("image", "img", 0), v.attrs = r = [["src", x], ["alt", ""]], v.children = E, v.content = i, _ && r.push(["title", _])), e.pos = u, e.posMax = m, !0;
  }, mt;
}
var bt, vo;
function l4() {
  if (vo) return bt;
  vo = 1;
  var c = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, n = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
  return bt = function(e, t) {
    var r, s, i, a, l, f, u = e.pos;
    if (e.src.charCodeAt(u) !== 60)
      return !1;
    for (l = e.pos, f = e.posMax; ; ) {
      if (++u >= f || (a = e.src.charCodeAt(u), a === 60)) return !1;
      if (a === 62) break;
    }
    return r = e.src.slice(l + 1, u), n.test(r) ? (s = e.md.normalizeLink(r), e.md.validateLink(s) ? (t || (i = e.push("link_open", "a", 1), i.attrs = [["href", s]], i.markup = "autolink", i.info = "auto", i = e.push("text", "", 0), i.content = e.md.normalizeLinkText(r), i = e.push("link_close", "a", -1), i.markup = "autolink", i.info = "auto"), e.pos += r.length + 2, !0) : !1) : c.test(r) ? (s = e.md.normalizeLink("mailto:" + r), e.md.validateLink(s) ? (t || (i = e.push("link_open", "a", 1), i.attrs = [["href", s]], i.markup = "autolink", i.info = "auto", i = e.push("text", "", 0), i.content = e.md.normalizeLinkText(r), i = e.push("link_close", "a", -1), i.markup = "autolink", i.info = "auto"), e.pos += r.length + 2, !0) : !1) : !1;
  }, bt;
}
var vt, ko;
function u4() {
  if (ko) return vt;
  ko = 1;
  var c = is().HTML_TAG_RE;
  function n(t) {
    return /^<a[>\s]/i.test(t);
  }
  function o(t) {
    return /^<\/a\s*>/i.test(t);
  }
  function e(t) {
    var r = t | 32;
    return r >= 97 && r <= 122;
  }
  return vt = function(r, s) {
    var i, a, l, f, u = r.pos;
    return !r.md.options.html || (l = r.posMax, r.src.charCodeAt(u) !== 60 || u + 2 >= l) || (i = r.src.charCodeAt(u + 1), i !== 33 && i !== 63 && i !== 47 && !e(i)) || (a = r.src.slice(u).match(c), !a) ? !1 : (s || (f = r.push("html_inline", "", 0), f.content = a[0], n(f.content) && r.linkLevel++, o(f.content) && r.linkLevel--), r.pos += a[0].length, !0);
  }, vt;
}
var kt, xo;
function f4() {
  if (xo) return kt;
  xo = 1;
  var c = ts(), n = Q().has, o = Q().isValidEntityCode, e = Q().fromCodePoint, t = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, r = /^&([a-z][a-z0-9]{1,31});/i;
  return kt = function(i, a) {
    var l, f, u, d, h = i.pos, _ = i.posMax;
    if (i.src.charCodeAt(h) !== 38 || h + 1 >= _) return !1;
    if (l = i.src.charCodeAt(h + 1), l === 35) {
      if (u = i.src.slice(h).match(t), u)
        return a || (f = u[1][0].toLowerCase() === "x" ? parseInt(u[1].slice(1), 16) : parseInt(u[1], 10), d = i.push("text_special", "", 0), d.content = o(f) ? e(f) : e(65533), d.markup = u[0], d.info = "entity"), i.pos += u[0].length, !0;
    } else if (u = i.src.slice(h).match(r), u && n(c, u[1]))
      return a || (d = i.push("text_special", "", 0), d.content = c[u[1]], d.markup = u[0], d.info = "entity"), i.pos += u[0].length, !0;
    return !1;
  }, kt;
}
var xt, yo;
function h4() {
  if (yo) return xt;
  yo = 1;
  function c(n) {
    var o, e, t, r, s, i, a, l, f = {}, u = n.length;
    if (u) {
      var d = 0, h = -2, _ = [];
      for (o = 0; o < u; o++)
        if (t = n[o], _.push(0), (n[d].marker !== t.marker || h !== t.token - 1) && (d = o), h = t.token, t.length = t.length || 0, !!t.close) {
          for (f.hasOwnProperty(t.marker) || (f[t.marker] = [-1, -1, -1, -1, -1, -1]), s = f[t.marker][(t.open ? 3 : 0) + t.length % 3], e = d - _[d] - 1, i = e; e > s; e -= _[e] + 1)
            if (r = n[e], r.marker === t.marker && r.open && r.end < 0 && (a = !1, (r.close || t.open) && (r.length + t.length) % 3 === 0 && (r.length % 3 !== 0 || t.length % 3 !== 0) && (a = !0), !a)) {
              l = e > 0 && !n[e - 1].open ? _[e - 1] + 1 : 0, _[o] = o - e + l, _[e] = l, t.open = !1, r.end = o, r.close = !1, i = -1, h = -2;
              break;
            }
          i !== -1 && (f[t.marker][(t.open ? 3 : 0) + (t.length || 0) % 3] = i);
        }
    }
  }
  return xt = function(o) {
    var e, t = o.tokens_meta, r = o.tokens_meta.length;
    for (c(o.delimiters), e = 0; e < r; e++)
      t[e] && t[e].delimiters && c(t[e].delimiters);
  }, xt;
}
var yt, Eo;
function p4() {
  return Eo || (Eo = 1, yt = function(n) {
    var o, e, t = 0, r = n.tokens, s = n.tokens.length;
    for (o = e = 0; o < s; o++)
      r[o].nesting < 0 && t--, r[o].level = t, r[o].nesting > 0 && t++, r[o].type === "text" && o + 1 < s && r[o + 1].type === "text" ? r[o + 1].content = r[o].content + r[o + 1].content : (o !== e && (r[e] = r[o]), e++);
    o !== e && (r.length = e);
  }), yt;
}
var Et, Ao;
function d4() {
  if (Ao) return Et;
  Ao = 1;
  var c = $t(), n = Q().isWhiteSpace, o = Q().isPunctChar, e = Q().isMdAsciiPunct;
  function t(r, s, i, a) {
    this.src = r, this.env = i, this.md = s, this.tokens = a, this.tokens_meta = Array(a.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
  }
  return t.prototype.pushPending = function() {
    var r = new c("text", "", 0);
    return r.content = this.pending, r.level = this.pendingLevel, this.tokens.push(r), this.pending = "", r;
  }, t.prototype.push = function(r, s, i) {
    this.pending && this.pushPending();
    var a = new c(r, s, i), l = null;
    return i < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), a.level = this.level, i > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], l = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(a), this.tokens_meta.push(l), a;
  }, t.prototype.scanDelims = function(r, s) {
    var i = r, a, l, f, u, d, h, _, v, E, b = !0, x = !0, g = this.posMax, m = this.src.charCodeAt(r);
    for (a = r > 0 ? this.src.charCodeAt(r - 1) : 32; i < g && this.src.charCodeAt(i) === m; )
      i++;
    return f = i - r, l = i < g ? this.src.charCodeAt(i) : 32, _ = e(a) || o(String.fromCharCode(a)), E = e(l) || o(String.fromCharCode(l)), h = n(a), v = n(l), v ? b = !1 : E && (h || _ || (b = !1)), h ? x = !1 : _ && (v || E || (x = !1)), s ? (u = b, d = x) : (u = b && (!x || _), d = x && (!b || E)), {
      can_open: u,
      can_close: d,
      length: f
    };
  }, t.prototype.Token = c, Et = t, Et;
}
var At, Co;
function g4() {
  if (Co) return At;
  Co = 1;
  var c = zt(), n = [
    ["text", t4()],
    ["linkify", r4()],
    ["newline", o4()],
    ["escape", s4()],
    ["backticks", c4()],
    ["strikethrough", po().tokenize],
    ["emphasis", _o().tokenize],
    ["link", i4()],
    ["image", a4()],
    ["autolink", l4()],
    ["html_inline", u4()],
    ["entity", f4()]
  ], o = [
    ["balance_pairs", h4()],
    ["strikethrough", po().postProcess],
    ["emphasis", _o().postProcess],
    // rules for pairs separate '**' into its own text tokens, which may be left unused,
    // rule below merges unused segments back with the rest of the text
    ["fragments_join", p4()]
  ];
  function e() {
    var t;
    for (this.ruler = new c(), t = 0; t < n.length; t++)
      this.ruler.push(n[t][0], n[t][1]);
    for (this.ruler2 = new c(), t = 0; t < o.length; t++)
      this.ruler2.push(o[t][0], o[t][1]);
  }
  return e.prototype.skipToken = function(t) {
    var r, s, i = t.pos, a = this.ruler.getRules(""), l = a.length, f = t.md.options.maxNesting, u = t.cache;
    if (typeof u[i] < "u") {
      t.pos = u[i];
      return;
    }
    if (t.level < f) {
      for (s = 0; s < l; s++)
        if (t.level++, r = a[s](t, !0), t.level--, r) {
          if (i >= t.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    } else
      t.pos = t.posMax;
    r || t.pos++, u[i] = t.pos;
  }, e.prototype.tokenize = function(t) {
    for (var r, s, i, a = this.ruler.getRules(""), l = a.length, f = t.posMax, u = t.md.options.maxNesting; t.pos < f; ) {
      if (i = t.pos, t.level < u) {
        for (s = 0; s < l; s++)
          if (r = a[s](t, !1), r) {
            if (i >= t.pos)
              throw new Error("inline rule didn't increment state.pos");
            break;
          }
      }
      if (r) {
        if (t.pos >= f)
          break;
        continue;
      }
      t.pending += t.src[t.pos++];
    }
    t.pending && t.pushPending();
  }, e.prototype.parse = function(t, r, s, i) {
    var a, l, f, u = new this.State(t, r, s, i);
    for (this.tokenize(u), l = this.ruler2.getRules(""), f = l.length, a = 0; a < f; a++)
      l[a](u);
  }, e.prototype.State = d4(), At = e, At;
}
var Ct, wo;
function _4() {
  return wo || (wo = 1, Ct = function(c) {
    var n = {};
    c = c || {}, n.src_Any = os().source, n.src_Cc = ss().source, n.src_Z = cs().source, n.src_P = Pt().source, n.src_ZPCc = [n.src_Z, n.src_P, n.src_Cc].join("|"), n.src_ZCc = [n.src_Z, n.src_Cc].join("|");
    var o = "[><｜]";
    return n.src_pseudo_letter = "(?:(?!" + o + "|" + n.src_ZPCc + ")" + n.src_Any + ")", n.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", n.src_auth = "(?:(?:(?!" + n.src_ZCc + "|[@/\\[\\]()]).)+@)?", n.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", n.src_host_terminator = "(?=$|" + o + "|" + n.src_ZPCc + ")(?!" + (c["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + n.src_ZPCc + "))", n.src_path = "(?:[/?#](?:(?!" + n.src_ZCc + "|" + o + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + n.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + n.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + n.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + n.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + n.src_ZCc + "|[']).)+\\'|\\'(?=" + n.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + n.src_ZCc + "|[.]|$)|" + (c["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + n.src_ZCc + "|$)|;(?!" + n.src_ZCc + "|$)|\\!+(?!" + n.src_ZCc + "|[!]|$)|\\?(?!" + n.src_ZCc + "|[?]|$))+|\\/)?", n.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', n.src_xn = "xn--[a-z0-9\\-]{1,59}", n.src_domain_root = // Allow letters & digits (http://test1)
    "(?:" + n.src_xn + "|" + n.src_pseudo_letter + "{1,63})", n.src_domain = "(?:" + n.src_xn + "|(?:" + n.src_pseudo_letter + ")|(?:" + n.src_pseudo_letter + "(?:-|" + n.src_pseudo_letter + "){0,61}" + n.src_pseudo_letter + "))", n.src_host = "(?:(?:(?:(?:" + n.src_domain + ")\\.)*" + n.src_domain + "))", n.tpl_host_fuzzy = "(?:" + n.src_ip4 + "|(?:(?:(?:" + n.src_domain + ")\\.)+(?:%TLDS%)))", n.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + n.src_domain + ")\\.)+(?:%TLDS%))", n.src_host_strict = n.src_host + n.src_host_terminator, n.tpl_host_fuzzy_strict = n.tpl_host_fuzzy + n.src_host_terminator, n.src_host_port_strict = n.src_host + n.src_port + n.src_host_terminator, n.tpl_host_port_fuzzy_strict = n.tpl_host_fuzzy + n.src_port + n.src_host_terminator, n.tpl_host_port_no_ip_fuzzy_strict = n.tpl_host_no_ip_fuzzy + n.src_port + n.src_host_terminator, n.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + n.src_ZPCc + "|>|$))", n.tpl_email_fuzzy = "(^|" + o + '|"|\\(|' + n.src_ZCc + ")(" + n.src_email_name + "@" + n.tpl_host_fuzzy_strict + ")", n.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + n.src_ZPCc + "))((?![$+<=>^`|｜])" + n.tpl_host_port_fuzzy_strict + n.src_path + ")", n.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + n.src_ZPCc + "))((?![$+<=>^`|｜])" + n.tpl_host_port_no_ip_fuzzy_strict + n.src_path + ")", n;
  }), Ct;
}
var wt, So;
function m4() {
  if (So) return wt;
  So = 1;
  function c(g) {
    var m = Array.prototype.slice.call(arguments, 1);
    return m.forEach(function(k) {
      k && Object.keys(k).forEach(function(y) {
        g[y] = k[y];
      });
    }), g;
  }
  function n(g) {
    return Object.prototype.toString.call(g);
  }
  function o(g) {
    return n(g) === "[object String]";
  }
  function e(g) {
    return n(g) === "[object Object]";
  }
  function t(g) {
    return n(g) === "[object RegExp]";
  }
  function r(g) {
    return n(g) === "[object Function]";
  }
  function s(g) {
    return g.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
  }
  var i = {
    fuzzyLink: !0,
    fuzzyEmail: !0,
    fuzzyIP: !1
  };
  function a(g) {
    return Object.keys(g || {}).reduce(function(m, k) {
      return m || i.hasOwnProperty(k);
    }, !1);
  }
  var l = {
    "http:": {
      validate: function(g, m, k) {
        var y = g.slice(m);
        return k.re.http || (k.re.http = new RegExp(
          "^\\/\\/" + k.re.src_auth + k.re.src_host_port_strict + k.re.src_path,
          "i"
        )), k.re.http.test(y) ? y.match(k.re.http)[0].length : 0;
      }
    },
    "https:": "http:",
    "ftp:": "http:",
    "//": {
      validate: function(g, m, k) {
        var y = g.slice(m);
        return k.re.no_http || (k.re.no_http = new RegExp(
          "^" + k.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          "(?:localhost|(?:(?:" + k.re.src_domain + ")\\.)+" + k.re.src_domain_root + ")" + k.re.src_port + k.re.src_host_terminator + k.re.src_path,
          "i"
        )), k.re.no_http.test(y) ? m >= 3 && g[m - 3] === ":" || m >= 3 && g[m - 3] === "/" ? 0 : y.match(k.re.no_http)[0].length : 0;
      }
    },
    "mailto:": {
      validate: function(g, m, k) {
        var y = g.slice(m);
        return k.re.mailto || (k.re.mailto = new RegExp(
          "^" + k.re.src_email_name + "@" + k.re.src_host_strict,
          "i"
        )), k.re.mailto.test(y) ? y.match(k.re.mailto)[0].length : 0;
      }
    }
  }, f = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", u = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
  function d(g) {
    g.__index__ = -1, g.__text_cache__ = "";
  }
  function h(g) {
    return function(m, k) {
      var y = m.slice(k);
      return g.test(y) ? y.match(g)[0].length : 0;
    };
  }
  function _() {
    return function(g, m) {
      m.normalize(g);
    };
  }
  function v(g) {
    var m = g.re = _4()(g.__opts__), k = g.__tlds__.slice();
    g.onCompile(), g.__tlds_replaced__ || k.push(f), k.push(m.src_xn), m.src_tlds = k.join("|");
    function y(R) {
      return R.replace("%TLDS%", m.src_tlds);
    }
    m.email_fuzzy = RegExp(y(m.tpl_email_fuzzy), "i"), m.link_fuzzy = RegExp(y(m.tpl_link_fuzzy), "i"), m.link_no_ip_fuzzy = RegExp(y(m.tpl_link_no_ip_fuzzy), "i"), m.host_fuzzy_test = RegExp(y(m.tpl_host_fuzzy_test), "i");
    var I = [];
    g.__compiled__ = {};
    function w(R, q) {
      throw new Error('(LinkifyIt) Invalid schema "' + R + '": ' + q);
    }
    Object.keys(g.__schemas__).forEach(function(R) {
      var q = g.__schemas__[R];
      if (q !== null) {
        var V = { validate: null, link: null };
        if (g.__compiled__[R] = V, e(q)) {
          t(q.validate) ? V.validate = h(q.validate) : r(q.validate) ? V.validate = q.validate : w(R, q), r(q.normalize) ? V.normalize = q.normalize : q.normalize ? w(R, q) : V.normalize = _();
          return;
        }
        if (o(q)) {
          I.push(R);
          return;
        }
        w(R, q);
      }
    }), I.forEach(function(R) {
      g.__compiled__[g.__schemas__[R]] && (g.__compiled__[R].validate = g.__compiled__[g.__schemas__[R]].validate, g.__compiled__[R].normalize = g.__compiled__[g.__schemas__[R]].normalize);
    }), g.__compiled__[""] = { validate: null, normalize: _() };
    var D = Object.keys(g.__compiled__).filter(function(R) {
      return R.length > 0 && g.__compiled__[R];
    }).map(s).join("|");
    g.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + m.src_ZPCc + "))(" + D + ")", "i"), g.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + m.src_ZPCc + "))(" + D + ")", "ig"), g.re.schema_at_start = RegExp("^" + g.re.schema_search.source, "i"), g.re.pretest = RegExp(
      "(" + g.re.schema_test.source + ")|(" + g.re.host_fuzzy_test.source + ")|@",
      "i"
    ), d(g);
  }
  function E(g, m) {
    var k = g.__index__, y = g.__last_index__, I = g.__text_cache__.slice(k, y);
    this.schema = g.__schema__.toLowerCase(), this.index = k + m, this.lastIndex = y + m, this.raw = I, this.text = I, this.url = I;
  }
  function b(g, m) {
    var k = new E(g, m);
    return g.__compiled__[k.schema].normalize(k, g), k;
  }
  function x(g, m) {
    if (!(this instanceof x))
      return new x(g, m);
    m || a(g) && (m = g, g = {}), this.__opts__ = c({}, i, m), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = c({}, l, g), this.__compiled__ = {}, this.__tlds__ = u, this.__tlds_replaced__ = !1, this.re = {}, v(this);
  }
  return x.prototype.add = function(m, k) {
    return this.__schemas__[m] = k, v(this), this;
  }, x.prototype.set = function(m) {
    return this.__opts__ = c(this.__opts__, m), this;
  }, x.prototype.test = function(m) {
    if (this.__text_cache__ = m, this.__index__ = -1, !m.length)
      return !1;
    var k, y, I, w, D, R, q, V, ne;
    if (this.re.schema_test.test(m)) {
      for (q = this.re.schema_search, q.lastIndex = 0; (k = q.exec(m)) !== null; )
        if (w = this.testSchemaAt(m, k[2], q.lastIndex), w) {
          this.__schema__ = k[2], this.__index__ = k.index + k[1].length, this.__last_index__ = k.index + k[0].length + w;
          break;
        }
    }
    return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (V = m.search(this.re.host_fuzzy_test), V >= 0 && (this.__index__ < 0 || V < this.__index__) && (y = m.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (D = y.index + y[1].length, (this.__index__ < 0 || D < this.__index__) && (this.__schema__ = "", this.__index__ = D, this.__last_index__ = y.index + y[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (ne = m.indexOf("@"), ne >= 0 && (I = m.match(this.re.email_fuzzy)) !== null && (D = I.index + I[1].length, R = I.index + I[0].length, (this.__index__ < 0 || D < this.__index__ || D === this.__index__ && R > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = D, this.__last_index__ = R))), this.__index__ >= 0;
  }, x.prototype.pretest = function(m) {
    return this.re.pretest.test(m);
  }, x.prototype.testSchemaAt = function(m, k, y) {
    return this.__compiled__[k.toLowerCase()] ? this.__compiled__[k.toLowerCase()].validate(m, y, this) : 0;
  }, x.prototype.match = function(m) {
    var k = 0, y = [];
    this.__index__ >= 0 && this.__text_cache__ === m && (y.push(b(this, k)), k = this.__last_index__);
    for (var I = k ? m.slice(k) : m; this.test(I); )
      y.push(b(this, k)), I = I.slice(this.__last_index__), k += this.__last_index__;
    return y.length ? y : null;
  }, x.prototype.matchAtStart = function(m) {
    if (this.__text_cache__ = m, this.__index__ = -1, !m.length) return null;
    var k = this.re.schema_at_start.exec(m);
    if (!k) return null;
    var y = this.testSchemaAt(m, k[2], k[0].length);
    return y ? (this.__schema__ = k[2], this.__index__ = k.index + k[1].length, this.__last_index__ = k.index + k[0].length + y, b(this, 0)) : null;
  }, x.prototype.tlds = function(m, k) {
    return m = Array.isArray(m) ? m : [m], k ? (this.__tlds__ = this.__tlds__.concat(m).sort().filter(function(y, I, w) {
      return y !== w[I - 1];
    }).reverse(), v(this), this) : (this.__tlds__ = m.slice(), this.__tlds_replaced__ = !0, v(this), this);
  }, x.prototype.normalize = function(m) {
    m.schema || (m.url = "http://" + m.url), m.schema === "mailto:" && !/^mailto:/i.test(m.url) && (m.url = "mailto:" + m.url);
  }, x.prototype.onCompile = function() {
  }, wt = x, wt;
}
const Ue = 2147483647, Se = 36, Ut = 1, Ye = 26, b4 = 38, v4 = 700, as = 72, ls = 128, us = "-", k4 = /^xn--/, x4 = /[^\0-\x7F]/, y4 = /[\x2E\u3002\uFF0E\uFF61]/g, E4 = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, St = Se - Ut, Re = Math.floor, Rt = String.fromCharCode;
function Le(c) {
  throw new RangeError(E4[c]);
}
function A4(c, n) {
  const o = [];
  let e = c.length;
  for (; e--; )
    o[e] = n(c[e]);
  return o;
}
function fs(c, n) {
  const o = c.split("@");
  let e = "";
  o.length > 1 && (e = o[0] + "@", c = o[1]), c = c.replace(y4, ".");
  const t = c.split("."), r = A4(t, n).join(".");
  return e + r;
}
function Ht(c) {
  const n = [];
  let o = 0;
  const e = c.length;
  for (; o < e; ) {
    const t = c.charCodeAt(o++);
    if (t >= 55296 && t <= 56319 && o < e) {
      const r = c.charCodeAt(o++);
      (r & 64512) == 56320 ? n.push(((t & 1023) << 10) + (r & 1023) + 65536) : (n.push(t), o--);
    } else
      n.push(t);
  }
  return n;
}
const hs = (c) => String.fromCodePoint(...c), C4 = function(c) {
  return c >= 48 && c < 58 ? 26 + (c - 48) : c >= 65 && c < 91 ? c - 65 : c >= 97 && c < 123 ? c - 97 : Se;
}, Ro = function(c, n) {
  return c + 22 + 75 * (c < 26) - ((n != 0) << 5);
}, ps = function(c, n, o) {
  let e = 0;
  for (c = o ? Re(c / v4) : c >> 1, c += Re(c / n); c > St * Ye >> 1; e += Se)
    c = Re(c / St);
  return Re(e + (St + 1) * c / (c + b4));
}, Gt = function(c) {
  const n = [], o = c.length;
  let e = 0, t = ls, r = as, s = c.lastIndexOf(us);
  s < 0 && (s = 0);
  for (let i = 0; i < s; ++i)
    c.charCodeAt(i) >= 128 && Le("not-basic"), n.push(c.charCodeAt(i));
  for (let i = s > 0 ? s + 1 : 0; i < o; ) {
    const a = e;
    for (let f = 1, u = Se; ; u += Se) {
      i >= o && Le("invalid-input");
      const d = C4(c.charCodeAt(i++));
      d >= Se && Le("invalid-input"), d > Re((Ue - e) / f) && Le("overflow"), e += d * f;
      const h = u <= r ? Ut : u >= r + Ye ? Ye : u - r;
      if (d < h)
        break;
      const _ = Se - h;
      f > Re(Ue / _) && Le("overflow"), f *= _;
    }
    const l = n.length + 1;
    r = ps(e - a, l, a == 0), Re(e / l) > Ue - t && Le("overflow"), t += Re(e / l), e %= l, n.splice(e++, 0, t);
  }
  return String.fromCodePoint(...n);
}, Vt = function(c) {
  const n = [];
  c = Ht(c);
  const o = c.length;
  let e = ls, t = 0, r = as;
  for (const a of c)
    a < 128 && n.push(Rt(a));
  const s = n.length;
  let i = s;
  for (s && n.push(us); i < o; ) {
    let a = Ue;
    for (const f of c)
      f >= e && f < a && (a = f);
    const l = i + 1;
    a - e > Re((Ue - t) / l) && Le("overflow"), t += (a - e) * l, e = a;
    for (const f of c)
      if (f < e && ++t > Ue && Le("overflow"), f === e) {
        let u = t;
        for (let d = Se; ; d += Se) {
          const h = d <= r ? Ut : d >= r + Ye ? Ye : d - r;
          if (u < h)
            break;
          const _ = u - h, v = Se - h;
          n.push(
            Rt(Ro(h + _ % v, 0))
          ), u = Re(_ / v);
        }
        n.push(Rt(Ro(u, 0))), r = ps(t, l, i === s), t = 0, ++i;
      }
    ++t, ++e;
  }
  return n.join("");
}, ds = function(c) {
  return fs(c, function(n) {
    return k4.test(n) ? Gt(n.slice(4).toLowerCase()) : n;
  });
}, gs = function(c) {
  return fs(c, function(n) {
    return x4.test(n) ? "xn--" + Vt(n) : n;
  });
}, w4 = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: Ht,
    encode: hs
  },
  decode: Gt,
  encode: Vt,
  toASCII: gs,
  toUnicode: ds
}, S4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Gt,
  default: w4,
  encode: Vt,
  toASCII: gs,
  toUnicode: ds,
  ucs2decode: Ht,
  ucs2encode: hs
}, Symbol.toStringTag, { value: "Module" })), R4 = /* @__PURE__ */ Fc(S4);
var Dt, Do;
function D4() {
  return Do || (Do = 1, Dt = {
    options: {
      html: !1,
      // Enable HTML tags in source
      xhtmlOut: !1,
      // Use '/' to close single tags (<br />)
      breaks: !1,
      // Convert '\n' in paragraphs into <br>
      langPrefix: "language-",
      // CSS language prefix for fenced blocks
      linkify: !1,
      // autoconvert URL-like texts to links
      // Enable some language-neutral replacements + quotes beautification
      typographer: !1,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: "“”‘’",
      /* “”‘’ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      maxNesting: 100
      // Internal protection, recursion limit
    },
    components: {
      core: {},
      block: {},
      inline: {}
    }
  }), Dt;
}
var Tt, To;
function T4() {
  return To || (To = 1, Tt = {
    options: {
      html: !1,
      // Enable HTML tags in source
      xhtmlOut: !1,
      // Use '/' to close single tags (<br />)
      breaks: !1,
      // Convert '\n' in paragraphs into <br>
      langPrefix: "language-",
      // CSS language prefix for fenced blocks
      linkify: !1,
      // autoconvert URL-like texts to links
      // Enable some language-neutral replacements + quotes beautification
      typographer: !1,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: "“”‘’",
      /* “”‘’ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      maxNesting: 20
      // Internal protection, recursion limit
    },
    components: {
      core: {
        rules: [
          "normalize",
          "block",
          "inline",
          "text_join"
        ]
      },
      block: {
        rules: [
          "paragraph"
        ]
      },
      inline: {
        rules: [
          "text"
        ],
        rules2: [
          "balance_pairs",
          "fragments_join"
        ]
      }
    }
  }), Tt;
}
var Mt, Mo;
function M4() {
  return Mo || (Mo = 1, Mt = {
    options: {
      html: !0,
      // Enable HTML tags in source
      xhtmlOut: !0,
      // Use '/' to close single tags (<br />)
      breaks: !1,
      // Convert '\n' in paragraphs into <br>
      langPrefix: "language-",
      // CSS language prefix for fenced blocks
      linkify: !1,
      // autoconvert URL-like texts to links
      // Enable some language-neutral replacements + quotes beautification
      typographer: !1,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: "“”‘’",
      /* “”‘’ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      maxNesting: 20
      // Internal protection, recursion limit
    },
    components: {
      core: {
        rules: [
          "normalize",
          "block",
          "inline",
          "text_join"
        ]
      },
      block: {
        rules: [
          "blockquote",
          "code",
          "fence",
          "heading",
          "hr",
          "html_block",
          "lheading",
          "list",
          "reference",
          "paragraph"
        ]
      },
      inline: {
        rules: [
          "autolink",
          "backticks",
          "emphasis",
          "entity",
          "escape",
          "html_inline",
          "image",
          "link",
          "newline",
          "text"
        ],
        rules2: [
          "balance_pairs",
          "emphasis",
          "fragments_join"
        ]
      }
    }
  }), Mt;
}
var Nt, No;
function N4() {
  if (No) return Nt;
  No = 1;
  var c = Q(), n = M5(), o = N5(), e = $5(), t = n4(), r = g4(), s = m4(), i = rs(), a = R4, l = {
    default: D4(),
    zero: T4(),
    commonmark: M4()
  }, f = /^(vbscript|javascript|file|data):/, u = /^data:image\/(gif|png|jpeg|webp);/;
  function d(b) {
    var x = b.trim().toLowerCase();
    return f.test(x) ? !!u.test(x) : !0;
  }
  var h = ["http:", "https:", "mailto:"];
  function _(b) {
    var x = i.parse(b, !0);
    if (x.hostname && (!x.protocol || h.indexOf(x.protocol) >= 0))
      try {
        x.hostname = a.toASCII(x.hostname);
      } catch {
      }
    return i.encode(i.format(x));
  }
  function v(b) {
    var x = i.parse(b, !0);
    if (x.hostname && (!x.protocol || h.indexOf(x.protocol) >= 0))
      try {
        x.hostname = a.toUnicode(x.hostname);
      } catch {
      }
    return i.decode(i.format(x), i.decode.defaultChars + "%");
  }
  function E(b, x) {
    if (!(this instanceof E))
      return new E(b, x);
    x || c.isString(b) || (x = b || {}, b = "default"), this.inline = new r(), this.block = new t(), this.core = new e(), this.renderer = new o(), this.linkify = new s(), this.validateLink = d, this.normalizeLink = _, this.normalizeLinkText = v, this.utils = c, this.helpers = c.assign({}, n), this.options = {}, this.configure(b), x && this.set(x);
  }
  return E.prototype.set = function(b) {
    return c.assign(this.options, b), this;
  }, E.prototype.configure = function(b) {
    var x = this, g;
    if (c.isString(b) && (g = b, b = l[g], !b))
      throw new Error('Wrong `markdown-it` preset "' + g + '", check name');
    if (!b)
      throw new Error("Wrong `markdown-it` preset, can't be empty");
    return b.options && x.set(b.options), b.components && Object.keys(b.components).forEach(function(m) {
      b.components[m].rules && x[m].ruler.enableOnly(b.components[m].rules), b.components[m].rules2 && x[m].ruler2.enableOnly(b.components[m].rules2);
    }), this;
  }, E.prototype.enable = function(b, x) {
    var g = [];
    Array.isArray(b) || (b = [b]), ["core", "block", "inline"].forEach(function(k) {
      g = g.concat(this[k].ruler.enable(b, !0));
    }, this), g = g.concat(this.inline.ruler2.enable(b, !0));
    var m = b.filter(function(k) {
      return g.indexOf(k) < 0;
    });
    if (m.length && !x)
      throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + m);
    return this;
  }, E.prototype.disable = function(b, x) {
    var g = [];
    Array.isArray(b) || (b = [b]), ["core", "block", "inline"].forEach(function(k) {
      g = g.concat(this[k].ruler.disable(b, !0));
    }, this), g = g.concat(this.inline.ruler2.disable(b, !0));
    var m = b.filter(function(k) {
      return g.indexOf(k) < 0;
    });
    if (m.length && !x)
      throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + m);
    return this;
  }, E.prototype.use = function(b) {
    var x = [this].concat(Array.prototype.slice.call(arguments, 1));
    return b.apply(b, x), this;
  }, E.prototype.parse = function(b, x) {
    if (typeof b != "string")
      throw new Error("Input data should be a String");
    var g = new this.core.State(b, this, x);
    return this.core.process(g), g.tokens;
  }, E.prototype.render = function(b, x) {
    return x = x || {}, this.renderer.render(this.parse(b, x), this.options, x);
  }, E.prototype.parseInline = function(b, x) {
    var g = new this.core.State(b, this, x);
    return g.inlineMode = !0, this.core.process(g), g.tokens;
  }, E.prototype.renderInline = function(b, x) {
    return x = x || {}, this.renderer.render(this.parseInline(b, x), this.options, x);
  }, Nt = E, Nt;
}
var It, Io;
function I4() {
  return Io || (Io = 1, It = N4()), It;
}
var L4 = I4();
const q4 = /* @__PURE__ */ Ot(L4), F4 = ye({
  name: "VueMarkdown",
  props: {
    source: {
      type: String,
      required: !0
    },
    options: {
      type: Object,
      required: !1
    },
    plugins: {
      type: Array,
      required: !1
    }
  },
  setup(c) {
    const n = _e(new q4(c.options ?? {}));
    for (const e of c.plugins ?? [])
      n.value.use(e);
    const o = me(() => n.value.render(c.source));
    return () => _c("div", { innerHTML: o.value });
  }
}), O4 = {
  key: 0,
  class: "chat-message-actions"
}, B4 = {
  key: 2,
  class: "chat-message-files"
}, Lt = /* @__PURE__ */ ye({
  __name: "Message",
  props: {
    message: {}
  },
  setup(c, { expose: n }) {
    const o = c;
    Te.registerLanguage("javascript", Zo), Te.registerLanguage("typescript", Qi), Te.registerLanguage("python", Ji), Te.registerLanguage("xml", jo), Te.registerLanguage("bash", Yi);
    const { message: e } = mc(o), { options: t } = Je(), r = _e(null), s = _e({}), i = me(() => e.value.text || "&lt;Empty response&gt;"), a = me(() => ({
      "chat-message-from-user": e.value.sender === "user",
      "chat-message-from-bot": e.value.sender === "bot",
      "chat-message-transparent": e.value.transparent === !0
    })), l = (_) => {
      _.use(ta, {
        attrs: {
          target: "_blank",
          rel: "noopener"
        }
      });
    }, f = () => {
      var _;
      (_ = r.value) != null && _.scrollIntoView && r.value.scrollIntoView({
        block: "start"
      });
    }, u = {
      highlight(_, v) {
        if (v && Te.getLanguage(v))
          try {
            return Te.highlight(_, { language: v }).value;
          } catch {
          }
        return "";
      }
    }, d = { ...(t == null ? void 0 : t.messageComponents) ?? {} };
    n({ scrollToView: f });
    const h = async (_) => await new Promise((v, E) => {
      const b = new FileReader();
      b.onload = () => v(b.result), b.onerror = E, b.readAsDataURL(_);
    });
    return Ge(async () => {
      if (e.value.files)
        for (const _ of e.value.files)
          try {
            const v = await h(_);
            s.value[_.name] = v;
          } catch (v) {
            console.error("Error reading file:", v);
          }
    }), (_, v) => (P(), W("div", {
      ref_key: "messageContainer",
      ref: r,
      class: Oo(["chat-message", a.value])
    }, [
      _.$slots.beforeMessage ? (P(), W("div", O4, [
        qe(_.$slots, "beforeMessage", ar(bc({ message: K(e) })))
      ])) : xe("", !0),
      qe(_.$slots, "default", {}, () => [
        K(e).type === "component" && d[K(e).key] ? (P(), pe(vc(d[K(e).key]), ar(Bo({ key: 0 }, K(e).arguments)), null, 16)) : (P(), pe(K(F4), {
          key: 1,
          class: "chat-message-markdown",
          source: i.value,
          options: u,
          plugins: [l]
        }, null, 8, ["source", "plugins"])),
        (K(e).files ?? []).length > 0 ? (P(), W("div", B4, [
          (P(!0), W(un, null, fn(K(e).files ?? [], (E) => (P(), W("div", {
            key: E.name,
            class: "chat-message-file"
          }, [
            ke(Ko, {
              file: E,
              "is-removable": !1,
              "is-previewable": !0
            }, null, 8, ["file"])
          ]))), 128))
        ])) : xe("", !0)
      ])
    ], 2));
  }
}), P4 = /* @__PURE__ */ ye({
  __name: "MessageTyping",
  props: {
    animation: { default: "bouncing" }
  },
  setup(c) {
    const n = c, o = {
      id: "typing",
      text: "",
      sender: "bot"
    }, e = _e(), t = me(() => ({
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "chat-message-typing": !0,
      [`chat-message-typing-animation-${n.animation}`]: !0
    }));
    return Ge(() => {
      var r;
      (r = e.value) == null || r.scrollToView();
    }), (r, s) => (P(), pe(K(Lt), {
      ref_key: "messageContainer",
      ref: e,
      class: Oo(t.value),
      message: o,
      "data-test-id": "chat-message-typing"
    }, {
      default: Me(() => s[0] || (s[0] = [
        re("div", { class: "chat-message-typing-body" }, [
          re("span", { class: "chat-message-typing-circle" }),
          re("span", { class: "chat-message-typing-circle" }),
          re("span", { class: "chat-message-typing-circle" })
        ], -1)
      ])),
      _: 1
    }, 8, ["class"]));
  }
}), z4 = {
  key: 0,
  class: "empty-container"
}, $4 = {
  class: "empty",
  "data-test-id": "chat-messages-empty"
}, U4 = {
  key: 1,
  class: "chat-messages-list"
}, H4 = /* @__PURE__ */ ye({
  __name: "MessagesList",
  props: {
    messages: {},
    emptyText: {}
  },
  setup(c) {
    const n = Bt(), o = _e([]), { initialMessages: e, waitingForResponse: t } = n;
    return kc(
      () => o.value.length,
      () => {
        const r = o.value[o.value.length - 1];
        r && r.scrollToView();
      }
    ), (r, s) => {
      const i = lr("N8nIcon"), a = lr("N8nText");
      return r.emptyText && K(e).length === 0 && r.messages.length === 0 ? (P(), W("div", z4, [
        re("div", $4, [
          ke(i, {
            icon: "comment",
            size: "large",
            class: "emptyIcon"
          }),
          ke(a, {
            tag: "p",
            size: "medium",
            color: "text-base"
          }, {
            default: Me(() => [
              qt(He(r.emptyText), 1)
            ]),
            _: 1
          })
        ])
      ])) : (P(), W("div", U4, [
        (P(!0), W(un, null, fn(K(e), (l) => (P(), pe(Lt, {
          key: l.id,
          message: l
        }, null, 8, ["message"]))), 128)),
        (P(!0), W(un, null, fn(r.messages, (l) => (P(), pe(Lt, {
          key: l.id,
          ref_for: !0,
          ref_key: "messageComponents",
          ref: o,
          message: l
        }, {
          beforeMessage: Me(({ message: f }) => [
            qe(r.$slots, "beforeMessage", Bo({ ref_for: !0 }, { message: f }))
          ]),
          _: 2
        }, 1032, ["message"]))), 128)),
        K(t) ? (P(), pe(P4, { key: 0 })) : xe("", !0)
      ]));
    };
  }
}), G4 = { class: "chat-heading" }, V4 = ["title"], Z4 = { key: 0 }, _s = /* @__PURE__ */ ye({
  __name: "Chat",
  setup(c) {
    const { t: n } = dn(), o = Bt(), { messages: e, currentSessionId: t } = o, { options: r } = Je(), s = me(() => r.mode === "window" && r.showWindowCloseButton);
    async function i() {
      o.startNewSession && (o.startNewSession(), We(() => {
        be.emit("scrollToBottom");
      }));
    }
    async function a() {
      o.loadPreviousSession && (await o.loadPreviousSession(), We(() => {
        be.emit("scrollToBottom");
      }));
    }
    function l() {
      be.emit("close");
    }
    return Ge(async () => {
      await a(), !r.showWelcomeScreen && !t.value && await i();
    }), (f, u) => (P(), pe(Wi, { class: "chat-wrapper" }, {
      header: Me(() => [
        re("div", G4, [
          re("h1", null, He(K(n)("title")), 1),
          s.value ? (P(), W("button", {
            key: 0,
            class: "chat-close-button",
            title: K(n)("closeButtonTooltip"),
            onClick: l
          }, [
            ke(K(Wc), {
              height: "18",
              width: "18"
            })
          ], 8, V4)) : xe("", !0)
        ]),
        K(n)("subtitle") ? (P(), W("p", Z4, He(K(n)("subtitle")), 1)) : xe("", !0)
      ]),
      footer: Me(() => [
        K(t) ? (P(), pe(Vi, { key: 0 })) : (P(), pe(oi, { key: 1 }))
      ]),
      default: Me(() => [
        !K(t) && K(r).showWelcomeScreen ? (P(), pe(Jc, {
          key: 0,
          "onClick:button": i
        })) : (P(), pe(H4, {
          key: 1,
          messages: K(e)
        }, null, 8, ["messages"]))
      ]),
      _: 1
    }));
  }
}), j4 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function K4(c, n) {
  return P(), W("svg", j4, n[0] || (n[0] = [
    re("path", {
      fill: "currentColor",
      d: "M12 3c5.5 0 10 3.58 10 8s-4.5 8-10 8c-1.24 0-2.43-.18-3.53-.5C5.55 21 2 21 2 21c2.33-2.33 2.7-3.9 2.75-4.5C3.05 15.07 2 13.13 2 11c0-4.42 4.5-8 10-8"
    }, null, -1)
  ]));
}
const W4 = { name: "mdi-chat", render: K4 }, Y4 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function J4(c, n) {
  return P(), W("svg", Y4, n[0] || (n[0] = [
    re("path", {
      fill: "currentColor",
      d: "M7.41 8.58L12 13.17l4.59-4.59L18 10l-6 6l-6-6z"
    }, null, -1)
  ]));
}
const X4 = { name: "mdi-chevron-down", render: J4 }, Q4 = { class: "chat-window-wrapper" }, e9 = { class: "chat-window" }, n9 = /* @__PURE__ */ ye({
  __name: "ChatWindow",
  setup(c) {
    const n = _e(!1);
    function o() {
      n.value = !n.value, n.value && We(() => {
        be.emit("scrollToBottom");
      });
    }
    return (e, t) => (P(), W("div", Q4, [
      ke(ur, { name: "chat-window-transition" }, {
        default: Me(() => [
          Fo(re("div", e9, [
            ke(_s)
          ], 512), [
            [xc, n.value]
          ])
        ]),
        _: 1
      }),
      re("div", {
        class: "chat-window-toggle",
        onClick: o
      }, [
        ke(ur, {
          name: "chat-window-toggle-transition",
          mode: "out-in"
        }, {
          default: Me(() => [
            n.value ? (P(), pe(K(X4), {
              key: 1,
              height: "32",
              width: "32"
            })) : (P(), pe(K(W4), {
              key: 0,
              height: "32",
              width: "32"
            }))
          ]),
          _: 1
        })
      ])
    ]));
  }
}), t9 = /* @__PURE__ */ ye({
  __name: "App",
  props: {},
  setup(c) {
    const { options: n } = Je(), o = me(() => n.mode === "fullscreen");
    return Ge(() => {
      Te.registerLanguage("xml", jo), Te.registerLanguage("javascript", Zo);
    }), (e, t) => o.value ? (P(), pe(K(_s), {
      key: 0,
      class: "n8n-chat"
    })) : (P(), pe(K(n9), {
      key: 1,
      class: "n8n-chat"
    }));
  }
});
function s9(c) {
  var t, r;
  const n = {
    ...Ze,
    ...c,
    webhookConfig: {
      ...Ze.webhookConfig,
      ...c == null ? void 0 : c.webhookConfig
    },
    i18n: {
      ...Ze.i18n,
      ...c == null ? void 0 : c.i18n,
      en: {
        ...(t = Ze.i18n) == null ? void 0 : t.en,
        ...(r = c == null ? void 0 : c.i18n) == null ? void 0 : r.en
      }
    },
    theme: {
      ...Ze.theme,
      ...c == null ? void 0 : c.theme
    }
  }, o = n.target ?? Ec;
  typeof o == "string" && Lc(o);
  const e = yc(t9);
  return e.use(qc, n), e.mount(o), e;
}
export {
  s9 as createChat
};
